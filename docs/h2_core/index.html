<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hydrogen Core · DOLPHYN</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DOLPHYN</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome Page</a></li><li><a class="tocitem" href="../solvers/">Solvers</a></li><li><a class="tocitem" href="../solve_model/">Solving the Model</a></li><li><a class="tocitem" href="../additional_features/">Additional Features</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><span class="tocitem">GenX</span><ul><li><a class="tocitem" href="../model_introduction/">GenX Introduction</a></li><li><a class="tocitem" href="../data_documentation/">Model Inputs/Outputs Documentation</a></li><li><a class="tocitem" href="../load_inputs/">GenX Inputs Functions</a></li><li><a class="tocitem" href="../write_outputs/">GenX Outputs Functions</a></li><li><a class="tocitem" href="../model_notation/">Notation</a></li><li><a class="tocitem" href="../objective_function/">Objective Function</a></li><li><a class="tocitem" href="../power_balance/">Power Balance</a></li><li><input class="collapse-toggle" id="menuitem-6-8" type="checkbox"/><label class="tocitem" for="menuitem-6-8"><span class="docs-label">GenX Function Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../core/">Core</a></li><li><input class="collapse-toggle" id="menuitem-6-8-2" type="checkbox"/><label class="tocitem" for="menuitem-6-8-2"><span class="docs-label">Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../curtailable_variable_renewable/">Curtailable Variable Renewable</a></li><li><a class="tocitem" href="../flexible_demand/">Flexible Demand</a></li><li><a class="tocitem" href="../hydro_res/">Hydro</a></li><li><a class="tocitem" href="../must_run/">Must Run</a></li><li><a class="tocitem" href="../storage/">Storage</a></li><li><a class="tocitem" href="../investment_charge/">Investment Charge</a></li><li><a class="tocitem" href="../investment_energy/">Investment Energy</a></li><li><a class="tocitem" href="../long_duration_storage/">Long Duration Storage</a></li><li><a class="tocitem" href="../storage_all/">Storage All</a></li><li><a class="tocitem" href="../storage_asymmetric/">Storage Asymmetric</a></li><li><a class="tocitem" href="../storage_symmetric/">Storage Symmetric</a></li><li><a class="tocitem" href="../thermal/">Thermal</a></li><li><a class="tocitem" href="../thermal_commit/">Thermal Commit</a></li><li><a class="tocitem" href="../thermal_no_commit/">Thermal No Commit</a></li></ul></li><li><a class="tocitem" href="../policies/">Policies</a></li></ul></li></ul></li><li><span class="tocitem">HSC</span><ul><li><a class="tocitem" href="../load_h2_inputs/">HSC Inputs Functions</a></li><li><a class="tocitem" href="../write_h2_outputs/">HSC Outputs Functions</a></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox" checked/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">HSC Function Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Hydrogen Core</a><ul class="internal"><li><a class="tocitem" href="#Hydrogen-Supply-Chain-Policies"><span>Hydrogen Supply Chain Policies</span></a></li><li><a class="tocitem" href="#Hydrogen-Resources-Investment"><span>Hydrogen Resources Investment</span></a></li><li><a class="tocitem" href="#Non-served-Hydrogen"><span>Non-served Hydrogen</span></a></li><li><a class="tocitem" href="#Hydrogen-Output"><span>Hydrogen Output</span></a></li></ul></li><li><a class="tocitem" href="../h2_flexible_demand/">Hydrogen Flexible Demand</a></li><li><a class="tocitem" href="../g2p/">Hydrogen to Power</a></li><li><input class="collapse-toggle" id="menuitem-7-3-4" type="checkbox"/><label class="tocitem" for="menuitem-7-3-4"><span class="docs-label">Hydrogen Storage</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../h2_long_duration_storage/">Hydrogen Long Duration Storage</a></li><li><a class="tocitem" href="../h2_storage_all/">Hydrogen Storage ALL</a></li><li><a class="tocitem" href="../h2_storage_investment/">Hydrogen Storage Investment</a></li><li><a class="tocitem" href="../h2_storage/">Hydrogen Storage</a></li></ul></li><li><a class="tocitem" href="../h2_transmission/">Hydrogen Transimission</a></li><li><input class="collapse-toggle" id="menuitem-7-3-6" type="checkbox"/><label class="tocitem" for="menuitem-7-3-6"><span class="docs-label">Hydrogen Truck</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../h2_long_duration_truck/">Hydrogen Long Duration Truck</a></li><li><a class="tocitem" href="../h2_truck_all/">Hydrogen Truck All</a></li><li><a class="tocitem" href="../h2_truck_investment/">Hydrogen Truck Investment</a></li><li><a class="tocitem" href="../h2_truck/">Hydrogen Truck</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3-7" type="checkbox"/><label class="tocitem" for="menuitem-7-3-7"><span class="docs-label">Hydrogen Production</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../h2_production_all/">Hydrogen Production All</a></li><li><a class="tocitem" href="../h2_production_commit/">Hydrogen Production Commit</a></li><li><a class="tocitem" href="../h2_production_no_commit/">Hydrogen Production No Commit</a></li><li><a class="tocitem" href="../h2_production/">Hydrogen Production</a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">HSC</a></li><li><a class="is-disabled">HSC Function Reference</a></li><li class="is-active"><a href>Hydrogen Core</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hydrogen Core</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gn-he/DOLPHYN-dev/blob/main/docs/src/h2_core.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Hydrogen-Supply-Chain-Policies"><a class="docs-heading-anchor" href="#Hydrogen-Supply-Chain-Policies">Hydrogen Supply Chain Policies</a><a id="Hydrogen-Supply-Chain-Policies-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen-Supply-Chain-Policies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.co2_cap_hsc-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.co2_cap_hsc-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.co2_cap_hsc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">co2_cap_hsc(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This policy constraints mimics the CO<span>$_2$</span> emissions cap and permit trading systems, allowing for emissions trading across each zone for which the cap applies. The constraint <span>$p \in \mathcal{P}^{CO_2}$</span> can be flexibly defined for mass-based or rate-based emission limits for one or more model zones, where zones can trade CO<span>$_2$</span> emissions permits and earn revenue based on their CO<span>$_2$</span> allowance. Note that if the model is fully linear (e.g. no unit commitment or linearized unit commitment), the dual variable of the emissions constraints can be interpreted as the marginal CO<span>$_2$</span> price per tonne associated with the emissions target. Alternatively, for integer model formulations, the marginal CO<span>$_2$</span> price can be obtained after solving the model with fixed integer/binary variables.</p><p>The CO<span>$_2$</span> emissions limit can be defined in one of the following ways: a) a mass-based limit defined in terms of annual CO<span>$_2$</span> emissions budget (in million tonnes of CO2), b) a load-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of demand and c) a generation-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of generation.</p><p><strong>Mass-based emissions constraint</strong></p><p>Mass-based emission limits are implemented in the following expression. For each constraint, <span>$p \in \mathcal{P}^{CO_2}_{mass}$</span>, we define a set of zones <span>$z \in \mathcal{Z}^{CO_2}_{p,mass}$</span> that can trade CO<span>$_2$</span> allowance. Input data for each constraint  <span>$p \in \mathcal{P}^{CO_2}_{mass}$</span> requires the CO<span>$_2$</span> allowance/ budget for each model zone, <span>$\epsilon^{CO_{2}}_{z,p, mass}$</span>, to be provided in terms of million metric tonnes. For every generator <span>$y$</span>, the parameter <span>$\epsilon_{y,z}^{CO_2}$</span> reflects the specific <span>$CO_2$</span> emission intensity in tCO<span>$_2$</span>/MWh associated with its operation.  The resulting constraint is given as:</p><p class="math-container">\[\begin{aligned}
	\sum_{z \in \mathcal{Z}^{CO_2}_{p,mass}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,z,t} \right)
	&amp; \leq \sum_{z \in \mathcal{Z}^{CO_2}_{p,mass}} \epsilon^{CO_{2}}_{z,p, mass} \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{mass}
\end{aligned}\]</p><p>In the above constraint, we include both power discharge and charge term for each resource to account for the potential for CO<span>$_2$</span> emissions (or removal when considering negative emissions technologies) associated with each step. Note that if a limit is applied to each zone separately, then the set <span>$\mathcal{Z}^{CO_2}_{p,mass}$</span> will contain only one zone with no possibility of trading. If a system-wide emission limit constraint is applied, then <span>$\mathcal{Z}^{CO_2}_{p,mass}$</span> will be equivalent to a set of all zones.</p><p><strong>Load-side rate-based emissions constraint</strong></p><p>We modify the right hand side of the above mass-based constraint, <span>$p \in \mathcal{P}^{CO_2}_{load}$</span>, to set emissions target based on a CO<span>$_2$</span> emission rate limit in tCO<span>$_2$</span>/MWh <span>$\times$</span> the total demand served in each zone. In the following constraint, total demand served takes into account non-served energy and storage related losses. Here, <span>$\epsilon_{z,p,load}^{maxCO_2}$</span> denotes the emission limit in terms on tCO<span>$_2$</span>/MWh.</p><p class="math-container">\[\begin{aligned}
	\sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,t,z} \right)
	\leq &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{t \in \mathcal{T}}  \left(\epsilon_{z,p,load}^{CO_2} \times  \omega_{t} \times D_{z,t} \right) \\  + &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{y \in \mathcal{O}}  \sum_{t \in \mathcal{T}} \left(\epsilon_{z,p,load}^{CO_2} \times \omega_{t} \times \left(\Pi_{y,t,z} - \Theta_{y,t,z} \right) \right) \\  - &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{s \in \mathcal{S} } \sum_{t \in \mathcal{T}}  \left(\epsilon_{z,p,load}^{CO_2} \times \omega_{t} \times \Lambda_{s,z,t}\right) \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{load}
\end{aligned}\]</p><p><strong>Generator-side emissions rate-based constraint</strong></p><p>Similarly, a generation based emission constraint is defined by setting the emission limit based on the total generation times the carbon emission rate limit in tCO<span>$_2$</span>/MWh of the region. The resulting constraint is given as:</p><p class="math-container">\[\begin{aligned}
\sum_{z \in \mathcal{Z}^{CO_2}_{p,gen}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} &amp; \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,t,z} \right) \\
	\leq \sum_{z \in \mathcal{Z}^{CO_2}_{p,gen}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} &amp; \left(\epsilon_{z,p,gen}^{CO_2} \times  \omega_{t} \times \Theta_{y,t,z} \right)  \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{gen}
\end{aligned}\]</p><p>Note that the generator-side rate-based constraint can be used to represent a fee-rebate (``feebate&#39;&#39;) system: the dirty generators that emit above the bar (<span>$\epsilon_{z,p,gen}^{maxCO_2}$</span>) have to buy emission allowances from the emission regulator in the region <span>$z$</span> where they are located; in the same vein, the clean generators get rebates from the emission regulator at an emission allowance price being the dual variable of the emissions rate constraint.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/policies/co2_cap_hsc.jl#L17-L60">source</a></section></article><h2 id="Hydrogen-Resources-Investment"><a class="docs-heading-anchor" href="#Hydrogen-Resources-Investment">Hydrogen Resources Investment</a><a id="Hydrogen-Resources-Investment-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen-Resources-Investment" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_investment-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_investment-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_investment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_discharge(EP::Model, inputs::Dict, UCommit::Int, Reserves::Int)</code></pre><p>This module defines the production decision variable representing hydrogen injected into the network by resource <span>$y$</span> by at time period <span>$t$</span>.</p><p>This module additionally defines contributions to the objective function from variable costs of generation (variable O&amp;M plus fuel cost) from all resources over all time periods.</p><p><strong>Variables</strong></p><p class="math-container">\[\begin{aligned}
	\vartheta _{k}^{GenNewCap}\ge 0	
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\vartheta _{k}^{GenRetCap}\ge 0
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total}_{y,z} =(\overline{\Delta_{y,z}}-\Delta_{y,z}) \forall y \in \mathcal{G}, z \in \mathcal{Z}
\end{aligned}\]</p><p>One cannot retire more capacity than existing capacity.</p><p class="math-container">\[\begin{aligned}
&amp;\Delta_{y,z} \leq \overline{\Delta_{y,z}}
	\hspace{4 cm}  \forall y \in \mathcal{G}, z \in \mathcal{Z}
\end{aligned}\]</p><p>In addition, this function adds investment and fixed O\&amp;M related costs related to discharge/generation capacity to the objective function:</p><p class="math-container">\[\begin{aligned}
&amp; 	\sum_{y \in \mathcal{G} } \sum_{z \in \mathcal{Z}}
	\left( (\pi^{INVEST}_{y,z} \times \overline{\Omega}^{size}_{y,z} \times  )
	+ (\pi^{FOM}_{y,z} \times \Delta^{total}_{y,z})\right)
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/core/h2_investment.jl#L17-L60">source</a></section></article><h2 id="Non-served-Hydrogen"><a class="docs-heading-anchor" href="#Non-served-Hydrogen">Non-served Hydrogen</a><a id="Non-served-Hydrogen-1"></a><a class="docs-heading-anchor-permalink" href="#Non-served-Hydrogen" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.RemoveConstCols" href="#DOLPHYN.RemoveConstCols"><code>DOLPHYN.RemoveConstCols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RemoveConstCols(all_profiles, all_col_names)</code></pre><p>Remove and store the columns that do not vary during the period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.cap_reserve_margin-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.cap_reserve_margin-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.cap_reserve_margin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cap_reserve_margin(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>Instead of modeling capacity reserve margin requirement (a.k.a. capacity market or resource adequacy requirement) using an annual constraint, we model each requirement with hourly constraint by simulating the activation of the capacity obligation. We define capacity reserve margin constraint for subsets of zones,<span>$z  \in \mathcal{Z}^{CRM}_{p}$</span>, and each subset stands for a locational deliverability area (LDA) or a reserve sharing group.  For thermal resources, the available capacity is the total capacity in the LDA derated by the outage rate, <span>$\epsilon_{y,z,p}^{CRM}$</span>. For storage (<span>$y \in \mathcal{O}$</span>), variable renewable energy (<span>$y \in \mathcal{VRE}$</span>), and  flexibile demand resources (<span>$y \in \mathcal{DF}$</span>), the available capacity is the net injection into the transmission network in time step <span>$t$</span> derated by the derating factor, also stored in the parameter, <span>$\epsilon_{y,z,p}^{CRM}$</span>. If the imported capacity is eligible to provide capacity to the CRM constraint, the inbound powerflow on all lines <span>$\mathcal{L}_{p}^{in}$</span> in time step <span>$t$</span> will be derated to form the available capacity from outside of the LDA. The reverse is true as well: the outbound derated powerflow on all lines <span>$\mathcal{L}_{p}^{out}$</span> in time step <span>$t$</span> is taken out from the total available capacity. The derating factor should be equal to the expected availability of the resource during periods when the capacity reserve constraint is binding (e.g. accounting for forced outages during supply constrained periods) and is similar to derating factors used in the capacity markets. On top of the flexible demand resources, load curtailment can also provide capacity (i.e., demand response or load management). We allow all segments of voluntary load curtailment, <span>$s \geq 2 \in S$</span>, to contribute to capacity requirements. The first segment <span>$s = 1 \in S$</span> corresponds to involuntary demand curtailment or emergency load shedding at the price cap or value of lost load, and thus does not contribute to reserve requirements.  Note that the time step-weighted sum of the shadow prices of this constraint corresponds to the capacity market payments reported by ISOs with mandate capacity market mechanism.</p><p class="math-container">\[\begin{aligned}
   &amp; \sum_{z  \in \mathcal{Z}^{CRM}_{p}} \Big( \sum_{y \in \mathcal{H}} \epsilon_{y,z,p}^{CRM} \times \Delta^{\text{total}}_{y,z} + \sum_{y \in \mathcal{VRE}} \epsilon_{y,z,p}^{CRM} \times \Theta_{y,z,t} \\
   + &amp; \sum_{y \in \mathcal{O}} \epsilon_{y,z,p}^{CRM} \times \left(\Theta_{y,z,t} - \Pi_{y,z,t} \right) + \sum_{y \in \mathcal{DF}} \epsilon_{y,z,p}^{CRM} \times \left(\Pi_{y,z,t} - \Theta_{y,z,t} \right) \\
   + &amp; \sum_{l \in \mathcal{L}_{p}^{in}} \epsilon_{y,z,p}^{CRM} \times \Phi_{l,t} -  \sum_{l \in \mathcal{L}_{p}^{out}} \epsilon_{y,z,p}^{CRM} \times \Phi_{l,t}
   +  \sum_{s \geq 2} \Lambda_{s,t,z}  \Big) \\
   &amp; \geq \sum_{z  \in \mathcal{Z}^{CRM}_{p}} \left( \left(1 + RM_{z,p}^{CRM} \right) \times D_{z,t} \right)  \hspace{1 cm}  \forall t \in \mathcal{T}, \forall p\in \mathcal{P}^{CRM}
\end{aligned}\]</p><p>Note that multiple capacity reserve margin requirements can be specified covering different individual zones or aggregations of zones, where the total number of constraints is specified by the GenX settings parameter <code>CapacityReserveMargin</code> (where this parameter should be an integer value &gt; 0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/policies/cap_reserve_margin.jl#L17-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.check_condition-NTuple{5, Any}" href="#DOLPHYN.check_condition-NTuple{5, Any}"><code>DOLPHYN.check_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_condition(Threshold, R, OldColNames, ScalingMethod, TimestepsPerRepPeriod)</code></pre><p>Check whether the greatest Euclidean deviation in the input data and the clustered representation is within a given proportion of the &quot;maximum&quot; possible deviation.</p><p>(1 for Normalization covers 100%, 4 for Standardization covers ~95%)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L221-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.choose_output_dir-Tuple{String}" href="#DOLPHYN.choose_output_dir-Tuple{String}"><code>DOLPHYN.choose_output_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">choose_output_dir(pathinit)</code></pre><p>Avoid overwriting (potentially important) existing results by appending to the directory name</p><p>Checks if the suggested output directory already exists. While yes, it appends _1, _2, etc till an unused name is found</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/choose_output_dir.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.cluster" href="#DOLPHYN.cluster"><code>DOLPHYN.cluster</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cluster(ClusterMethod, ClusteringInputDF, NClusters, nIters)</code></pre><p>Get representative periods using cluster centers from kmeans or kmedoids.</p><p>K-Means: https://juliastats.org/Clustering.jl/dev/kmeans.html</p><p>K-Medoids:  https://juliastats.org/Clustering.jl/stable/kmedoids.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L252-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.cluster_inputs" href="#DOLPHYN.cluster_inputs"><code>DOLPHYN.cluster_inputs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cluster_inputs(inpath, settings_path, v=false, norm_plot=false, silh_plot=false, res_plots=false, indiv_plots=false, pair_plots=false)</code></pre><p>Use kmeans or kmedoids to cluster raw load profiles and resource capacity factor profiles into representative periods. Use Extreme Periods to capture noteworthy periods or periods with notably poor fits.</p><p>In Load_data.csv, include the following:</p><ul><li>Timesteps_per_Rep_Period - Typically 168 timesteps (e.g., hours) per period, this designates the length   of each representative period.</li><li>UseExtremePeriods - Either 1 or 0, this designates whether or not to include  outliers (by performance or load/resource extreme) as their own representative periods.  This setting automatically includes the periods with maximum load, minimum solar cf and  minimum wind cf as extreme periods.</li><li>ClusterMethod - Either &#39;kmeans&#39; or &#39;kmedoids&#39;, this designates the method used to cluster  periods and determine each point&#39;s representative period.</li><li>ScalingMethod - Either &#39;N&#39; or &#39;S&#39;, this designates directs the module to normalize ([0,1])  or standardize (mean 0, variance 1) the input data.</li><li>MinPeriods - The minimum number of periods used to represent the input data. If using  UseExtremePeriods, this must be at least three. If IterativelyAddPeriods if off,  this will be the total number of periods.</li><li>MaxPeriods - The maximum number of periods - both clustered periods and extreme periods -  that may be used to represent the input data.</li><li>IterativelyAddPeriods - Either 1 or 0, this designates whether or not to add periods  until the error threshold between input data and represented data is met or the maximum  number of periods is reached.</li><li>Threshold - Iterative period addition will end if the period farthest (Euclidean Distance)  from its representative period is within this percentage of the total possible error (for normalization)  or ~95% of the total possible error (for standardization). E.g., for a threshold of 0.01,  every period must be within 1% of the spread of possible error before the clustering  iterations will terminate (or until the max number of periods is reached).</li><li>IterateMethod - Either &#39;cluster&#39; or &#39;extreme&#39;, this designates whether to add clusters to  the kmeans/kmedoids method or to set aside the worst-fitting periods as a new extreme periods.</li><li>nReps - The number of times to repeat each kmeans/kmedoids clustering at the same setting.</li><li>LoadWeight - Default 1, this is an optional multiplier on load columns in order to prioritize  better fits for load profiles over resource capacity factor profiles.</li><li>WeightTotal - Default 8760, the sum to which the relative weights of representative periods will be scaled.</li><li>ClusterFuelPrices - Either 1 or 0, this indicates whether or not to use the fuel price  time series in Fuels_data.csv in the clustering process. If &#39;no&#39;, this function will still write  Fuels_data_clustered.csv with reshaped fuel prices based on the number and size of the  representative weeks, assuming a constant time series of fuel prices with length equal to the  number of timesteps in the raw input data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L516-L559">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.co2_cap_power-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.co2_cap_power-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.co2_cap_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">co2_cap_power(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This policy constraints mimics the CO<span>$_2$</span> emissions cap and permit trading systems, allowing for emissions trading across each zone for which the cap applies. The constraint <span>$p \in \mathcal{P}^{CO_2}$</span> can be flexibly defined for mass-based or rate-based emission limits for one or more model zones, where zones can trade CO<span>$_2$</span> emissions permits and earn revenue based on their CO<span>$_2$</span> allowance. Note that if the model is fully linear (e.g. no unit commitment or linearized unit commitment), the dual variable of the emissions constraints can be interpreted as the marginal CO<span>$_2$</span> price per tonne associated with the emissions target. Alternatively, for integer model formulations, the marginal CO<span>$_2$</span> price can be obtained after solving the model with fixed integer/binary variables.</p><p>The CO<span>$_2$</span> emissions limit can be defined in one of the following ways: a) a mass-based limit defined in terms of annual CO<span>$_2$</span> emissions budget (in million tonnes of CO2), b) a load-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of demand and c) a generation-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of generation.</p><p><strong>Mass-based emissions constraint</strong></p><p>Mass-based emission limits are implemented in the following expression. For each constraint, <span>$p \in \mathcal{P}^{CO_2}_{mass}$</span>, we define a set of zones <span>$z \in \mathcal{Z}^{CO_2}_{p,mass}$</span> that can trade CO<span>$_2$</span> allowance. Input data for each constraint  <span>$p \in \mathcal{P}^{CO_2}_{mass}$</span> requires the CO<span>$_2$</span> allowance/ budget for each model zone, <span>$\epsilon^{CO_{2}}_{z,p, mass}$</span>, to be provided in terms of million metric tonnes. For every generator <span>$y$</span>, the parameter <span>$\epsilon_{y,z}^{CO_2}$</span> reflects the specific <span>$CO_2$</span> emission intensity in tCO<span>$_2$</span>/MWh associated with its operation.  The resulting constraint is given as:</p><p class="math-container">\[\begin{aligned}
    \sum_{z \in \mathcal{Z}^{CO_2}_{p,mass}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,z,t} \right)
   &amp; \leq \sum_{z \in \mathcal{Z}^{CO_2}_{p,mass}} \epsilon^{CO_{2}}_{z,p, mass} \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{mass}
\end{aligned}\]</p><p>In the above constraint, we include both power discharge and charge term for each resource to account for the potential for CO<span>$_2$</span> emissions (or removal when considering negative emissions technologies) associated with each step. Note that if a limit is applied to each zone separately, then the set <span>$\mathcal{Z}^{CO_2}_{p,mass}$</span> will contain only one zone with no possibility of trading. If a system-wide emission limit constraint is applied, then <span>$\mathcal{Z}^{CO_2}_{p,mass}$</span> will be equivalent to a set of all zones.</p><p><strong>Load-side rate-based emissions constraint</strong></p><p>We modify the right hand side of the above mass-based constraint, <span>$p \in \mathcal{P}^{CO_2}_{load}$</span>, to set emissions target based on a CO<span>$_2$</span> emission rate limit in tCO<span>$_2$</span>/MWh <span>$\times$</span> the total demand served in each zone. In the following constraint, total demand served takes into account non-served energy and storage related losses. Here, <span>$\epsilon_{z,p,load}^{maxCO_2}$</span> denotes the emission limit in terms on tCO<span>$_2$</span>/MWh.</p><p class="math-container">\[\begin{aligned}
    \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,t,z} \right)
    \leq &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{t \in \mathcal{T}}  \left(\epsilon_{z,p,load}^{CO_2} \times  \omega_{t} \times D_{z,t} \right) \\  + &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{y \in \mathcal{O}}  \sum_{t \in \mathcal{T}} \left(\epsilon_{z,p,load}^{CO_2} \times \omega_{t} \times \left(\Pi_{y,t,z} - \Theta_{y,t,z} \right) \right) \\  - &amp; \sum_{z \in \mathcal{Z}^{CO_2}_{p,load}} \sum_{s \in \mathcal{S} } \sum_{t \in \mathcal{T}}  \left(\epsilon_{z,p,load}^{CO_2} \times \omega_{t} \times \Lambda_{s,z,t}\right) \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{load}
\end{aligned}\]</p><p><strong>Generator-side emissions rate-based constraint</strong></p><p>Similarly, a generation based emission constraint is defined by setting the emission limit based on the total generation times the carbon emission rate limit in tCO<span>$_2$</span>/MWh of the region. The resulting constraint is given as:</p><p class="math-container">\[\begin{aligned}
\sum_{z \in \mathcal{Z}^{CO_2}_{p,gen}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} &amp; \left(\epsilon_{y,z}^{CO_2} \times \omega_{t} \times \Theta_{y,t,z} \right) \\
    \leq \sum_{z \in \mathcal{Z}^{CO_2}_{p,gen}} \sum_{y \in \mathcal{G}} \sum_{t \in \mathcal{T}} &amp; \left(\epsilon_{z,p,gen}^{CO_2} \times  \omega_{t} \times \Theta_{y,t,z} \right)  \hspace{1 cm}  \forall p \in \mathcal{P}^{CO_2}_{gen}
\end{aligned}\]</p><p>Note that the generator-side rate-based constraint can be used to represent a fee-rebate (``feebate&#39;&#39;) system: the dirty generators that emit above the bar (<span>$\epsilon_{z,p,gen}^{maxCO_2}$</span>) have to buy emission allowances from the emission regulator in the region <span>$z$</span> where they are located; in the same vein, the clean generators get rebates from the emission regulator at an emission allowance price being the dual variable of the emissions rate constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/policies/co2_cap_power.jl#L17-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.co2_cap_power_hsc-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.co2_cap_power_hsc-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.co2_cap_power_hsc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">co2_cap_power_hsc(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This policy constraints mimics the CO<span>$_2$</span> emissions cap and permit trading systems, allowing for emissions trading across each zone for which the cap applies. The constraint <span>$p \in \mathcal{P}^{CO_2}$</span> can be flexibly defined for mass-based or rate-based emission limits for one or more model zones, where zones can trade CO<span>$_2$</span> emissions permits and earn revenue based on their CO<span>$_2$</span> allowance. Note that if the model is fully linear (e.g. no unit commitment or linearized unit commitment), the dual variable of the emissions constraints can be interpreted as the marginal CO<span>$_2$</span> price per tonne associated with the emissions target. Alternatively, for integer model formulations, the marginal CO<span>$_2$</span> price can be obtained after solving the model with fixed integer/binary variables.</p><p>The CO<span>$_2$</span> emissions limit can be defined in one of the following ways: a) a mass-based limit defined in terms of annual CO<span>$_2$</span> emissions budget (in million tonnes of CO2), b) a load-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of demand and c) a generation-side rate-based limit defined in terms of tonnes CO<span>$_2$</span> per MWh of generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/co2_cap_power_hsc.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.configure_cbc-Tuple{String}" href="#DOLPHYN.configure_cbc-Tuple{String}"><code>DOLPHYN.configure_cbc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_cbc(solver_settings_path::String)</code></pre><p>Reads user-specified solver settings from cbc_settings.yml in the directory specified by the string solver_settings_path.</p><p>Returns a MathOptInterface OptimizerWithAttributes Cbc optimizer instance to be used in the generate_model() method.</p><p>The Cbc optimizer instance is configured with the following default parameters if a user-specified parameter for each respective field is not provided:</p><ul><li>seconds = 1e-6</li><li>logLevel = 1e-6</li><li>maxSolutions = -1</li><li>maxNodes = -1</li><li>allowableGap = -1</li><li>ratioGap = Inf</li><li>threads = 1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/configure_solver/configure_cbc.jl#L17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.configure_clp-Tuple{String}" href="#DOLPHYN.configure_clp-Tuple{String}"><code>DOLPHYN.configure_clp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_clp(solver_settings_path::String)</code></pre><p>Reads user-specified solver settings from clp_settings.yml in the directory specified by the string solver_settings_path.</p><p>Returns a MathOptInterface OptimizerWithAttributes Clp optimizer instance to be used in the generate_model() method.</p><p>The Clp optimizer instance is configured with the following default parameters if a user-specified parameter for each respective field is not provided:</p><ul><li>PrimalTolerance = 1e-7 (Primal feasibility tolerance)</li><li>DualTolerance = 1e-7 (Dual feasibility tolerance)</li><li>DualObjectiveLimit = 1e308 (When using dual simplex (where the objective is monotonically changing), terminate when the objective exceeds this limit)</li><li>MaximumIterations = 2147483647 (Terminate after performing this number of simplex iterations)</li><li>MaximumSeconds = -1.0	(Terminate after this many seconds have passed. A negative value means no time limit)</li><li>LogLevel = 1 (Set to 1, 2, 3, or 4 for increasing output. Set to 0 to disable output)</li><li>PresolveType = 0 (Set to 1 to disable presolve)</li><li>SolveType = 5 (Solution method: dual simplex (0), primal simplex (1), sprint (2), barrier with crossover (3), barrier without crossover (4), automatic (5))</li><li>InfeasibleReturn = 0 (Set to 1 to return as soon as the problem is found to be infeasible (by default, an infeasibility proof is computed as well))</li><li>Scaling = 3 (0 0ff, 1 equilibrium, 2 geometric, 3 auto, 4 dynamic (later))</li><li>Perturbation = 100 (switch on perturbation (50), automatic (100), don&#39;t try perturbing (102))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/configure_solver/configure_clp.jl#L17-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.configure_cplex-Tuple{String}" href="#DOLPHYN.configure_cplex-Tuple{String}"><code>DOLPHYN.configure_cplex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_cplex(solver_settings_path::String)</code></pre><p>Reads user-specified solver settings from cplex_settings.yml in the directory specified by the string solver_settings_path.</p><p>Returns a MathOptInterface OptimizerWithAttributes CPLEX optimizer instance to be used in the generate_model() method.</p><p>The CPLEX optimizer instance is configured with the following default parameters if a user-specified parameter for each respective field is not provided:</p><ul><li>CPX_PARAM_EPRHS = 1e-6 (Constraint (primal) feasibility tolerances. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/EpRHS.html)</li><li>CPX_PARAM_EPOPT = 1e-6 (Dual feasibility tolerances. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/EpOpt.html)</li><li>CPX_PARAM_AGGFILL = 10 (Allowed fill during presolve aggregation. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/AggFill.html)</li><li>CPX_PARAM_PREDUAL = 0 (Decides whether presolve should pass the primal or dual linear programming problem to the LP optimization algorithm. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/PreDual.html)</li><li>CPX_PARAM_TILIM = 1e+75	(Limits total time solver. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/TiLim.html)</li><li>CPX_PARAM_EPGAP = 1e-4	(Relative (p.u. of optimal) mixed integer optimality tolerance for MIP problems (ignored otherwise). See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/EpGap.html)</li><li>CPX_PARAM_LPMETHOD = 0 (Algorithm used to solve continuous models (including MIP root relaxation). See https://www.ibm.com/support/knowledgecenter/de/SSSA5P_12.7.0/ilog.odms.cplex.help/CPLEX/Parameters/topics/LPMETHOD.html)</li><li>CPX_PARAM_BAREPCOMP = 1e-8 (Barrier convergence tolerance (determines when barrier terminates). See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/BarEpComp.html)</li><li>CPX_PARAM_NUMERICALEMPHASIS = 0 (Numerical precision emphasis. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/NumericalEmphasis.html)</li><li>CPX_PARAM_BAROBJRNG = 1e+75 (Sets the maximum absolute value of the objective function. See https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.5.1/ilog.odms.cplex.help/CPLEX/Parameters/topics/BarObjRng.html)</li><li>CPX_PARAM_SOLUTIONTYPE = 2 (Solution type for LP or QP. See https://www.ibm.com/support/knowledgecenter/hr/SSSA5P_12.8.0/ilog.odms.cplex.help/CPLEX/Parameters/topics/SolutionType.html)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/configure_solver/configure_cplex.jl#L17-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.configure_gurobi-Tuple{String}" href="#DOLPHYN.configure_gurobi-Tuple{String}"><code>DOLPHYN.configure_gurobi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_gurobi(solver_settings_path::String)</code></pre><p>Reads user-specified solver settings from gurobi_settings.yml in the directory specified by the string solver_settings_path.</p><p>Returns a MathOptInterface OptimizerWithAttributes Gurobi optimizer instance to be used in the generate_model() method.</p><p>The Gurobi optimizer instance is configured with the following default parameters if a user-specified parameter for each respective field is not provided:</p><ul><li>FeasibilityTol = 1e-6 (Constraint (primal) feasibility tolerances. See https://www.gurobi.com/documentation/8.1/refman/feasibilitytol.html)</li><li>OptimalityTol = 1e-6 (Dual feasibility tolerances. See https://www.gurobi.com/documentation/8.1/refman/optimalitytol.html#parameter:OptimalityTol)</li><li>Presolve = -1 (Controls presolve level. See https://www.gurobi.com/documentation/8.1/refman/presolve.html)</li><li>AggFill = -1 (Allowed fill during presolve aggregation. See https://www.gurobi.com/documentation/8.1/refman/aggfill.html#parameter:AggFill)</li><li>PreDual = -1 (Presolve dualization. See https://www.gurobi.com/documentation/8.1/refman/predual.html#parameter:PreDual)</li><li>TimeLimit = Inf	(Limits total time solver. See https://www.gurobi.com/documentation/8.1/refman/timelimit.html)</li><li>MIPGap = 1e-4 (Relative (p.u. of optimal) mixed integer optimality tolerance for MIP problems (ignored otherwise). See https://www.gurobi.com/documentation/8.1/refman/mipgap2.html)</li><li>Crossover = -1 (Barrier crossver strategy. See https://www.gurobi.com/documentation/8.1/refman/crossover.html#parameter:Crossover)</li><li>Method = -1	(Algorithm used to solve continuous models (including MIP root relaxation). See https://www.gurobi.com/documentation/8.1/refman/method.html)</li><li>BarConvTol = 1e-8 (Barrier convergence tolerance (determines when barrier terminates). See https://www.gurobi.com/documentation/8.1/refman/barconvtol.html)</li><li>NumericFocus = 0 (Numerical precision emphasis. See https://www.gurobi.com/documentation/8.1/refman/numericfocus.html)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/configure_solver/configure_gurobi.jl#L17-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.configure_settings-Tuple{String}" href="#DOLPHYN.configure_settings-Tuple{String}"><code>DOLPHYN.configure_settings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_settings(settings_path::String)</code></pre><p>Function to configure generic settings from YAML file in settings_path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/configure_settings/configure_settings.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.configure_solver-Tuple{String, String}" href="#DOLPHYN.configure_solver-Tuple{String, String}"><code>DOLPHYN.configure_solver</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">configure_solver(solver::String, solver_settings_path::String)</code></pre><p>This method returns a solver-specific MathOptInterface OptimizerWithAttributes optimizer instance to be used in the generate_model() method.</p><p>The &quot;solver&quot; argument is a string which specifies the solver to be used, and can be either &quot;Gurobi&quot;, &quot;CPLEX&quot;, &quot;Clp&quot;, &quot;Cbc&quot;, &quot;Scip&quot;.</p><p>The &quot;solver_settings_path&quot; argument is a string which specifies the path to the directory that contains the settings YAML file for the specified solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/configure_solver/configure_solver.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.dftranspose-Tuple{DataFrames.DataFrame, Bool}" href="#DOLPHYN.dftranspose-Tuple{DataFrames.DataFrame, Bool}"><code>DOLPHYN.dftranspose</code></a> — <span class="docstring-category">Method</span></header><section><div><p>dftranspose(df::DataFrame, withhead::Bool)</p><p>Returns a transpose of a Dataframe.</p><p>FIXME: This is for DataFrames@0.20.2, as used in GenX.  Versions 0.21+ could use stack and unstack to make further changes while retaining the order</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/dftranspose.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.emissions_hsc-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.emissions_hsc-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.emissions_hsc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emissions_hsc(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function creates expression to add the CO2 emissions for hydrogen supply chain in each zone, which is subsequently added to the total emissions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/core/emissions_hsc.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.emissions_power-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.emissions_power-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.emissions_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">emissions_power(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function creates expression to add the CO2 emissions by plants in each zone, which is subsequently added to the total emissions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/core/emissions_power.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.energy_share_requirement-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.energy_share_requirement-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.energy_share_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">energy_share_requirement(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function establishes constraints that can be flexibily applied to define alternative forms of policies that require generation of a minimum quantity of megawatt-hours from a set of qualifying resources, such as renewable portfolio standard (RPS) or clean electricity standard (CES) policies prevalent in different jurisdictions. These policies usually require that the annual MWh generation from a subset of qualifying generators has to be higher than a pre-specified percentage of load from qualifying zones.</p><p>The implementation allows for user to define one or multiple RPS/CES style minimum energy share constraints, where each constraint can cover different combination of model zones to mimic real-world policy implementation (e.g. multiple state policies, multiple RPS tiers or overlapping RPS and CES policies). The number of energy share requirement constraints is specified by the user by the value of the GenX settings parameter <code>EnergyShareRequirement</code> (this value should be an integer &gt;=0). For each constraint <span>$p \in \mathcal{P}^{ESR}$</span>, we define a subset of zones <span>$z \in \mathcal{Z}^{ESR}_{p} \subset \mathcal{Z}$</span> that are eligible for trading renewable/clean energy credits to meet the corresponding renewable/clean energy requirement.</p><p>For each energy share requirement constraint <span>$p \in \mathcal{P}^{ESR}$</span>, we specify the share of total demand in each eligible model zone, <span>$z \in \mathcal{Z}^{ESR}_{p}$</span>, that must be served by qualifying resources, <span>$\mathcal{G}_{p}^{ESR} \subset \mathcal{G}$</span>:</p><p class="math-container">\[\begin{aligned}
&amp;\sum_{z \in \mathcal{Z}_{p}^{ESR}} \sum_{y \in \mathcal{G}_{p}^{ESR}} \sum_{t \in \mathcal{T}} (\omega_{t} \times  \Theta_{y,z,t}) \geq  \sum_{z \in \mathcal{Z}^{ESR}_{p}} \sum_{t \in \mathcal{T}} (\mu_{p,z}^{ESR} \times \omega_{t} \times D_{z,t}) + \\
&amp;\sum_{y \in \mathcal{O}} \sum_{z \in \mathcal{Z}^{ESR}_{p}} \sum_{t \in \mathcal{T}} \left(\mu_{p,z}^{ESR} \times \omega_{t} \times (\Pi_{y,z,t} - \Theta_{y,z,t}) \right) \hspace{1 cm}  \forall p \in \mathcal{P}^{ESR} \\
\end{aligned}\]</p><p>The final term in the summation above adds roundtrip storage losses to the total load to which the energy share obligation applies. This term is included in the constraint if the GenX setup parameter <code>StorageLosses=1</code>. If <code>StorageLosses=0</code>, this term is removed from the constraint. In practice, most existing renewable portfolio standard policies do not account for storage losses when determining energy share requirements. However, with 100% RPS or CES policies enacted in several jurisdictions, policy makers may wish to include storage losses in the minimum energy share, as otherwise there will be a difference between total generation and total load that will permit continued use of non-qualifying resources (e.g. emitting generators).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/policies/energy_share_requirement.jl#L17-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.fix_integers-Tuple{JuMP.Model}" href="#DOLPHYN.fix_integers-Tuple{JuMP.Model}"><code>DOLPHYN.fix_integers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_integers(jump_model::Model)</code></pre><p>inputs: jump_model - a model object containing that has been previously solved.</p><p>description: fixes the iteger variables ones the model has been solved in order to calculate approximations of dual variables</p><p>returns: none (modifies an existing-solved model in the memory). solve() must be run again to solve and getdual veriables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/solve_model.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.get_absolute_extreme-NTuple{4, Any}" href="#DOLPHYN.get_absolute_extreme-NTuple{4, Any}"><code>DOLPHYN.get_absolute_extreme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_absolute_extreme(DF, statKey, col_names, ConstCols)</code></pre><p>Get the period index of the single timestep with the minimum or maximum load or capacity factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L402-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.get_extreme_period" href="#DOLPHYN.get_extreme_period"><code>DOLPHYN.get_extreme_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_extreme_period(DF, GDF, profKey, typeKey, statKey,
   ConstCols, load_col_names, solar_col_names, wind_col_names)</code></pre><p>Identify extreme week by specification of profile type (Load, PV, Wind), measurement type (absolute (timestep with min/max value) vs. integral (period with min/max summed value)), and statistic (minimum or maximum). I.e., the user could want the hour with the most load across the whole system to be included among the extreme periods. They would select &quot;Load&quot;, &quot;System, &quot;Absolute, and &quot;Max&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L337-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.get_integral_extreme-NTuple{4, Any}" href="#DOLPHYN.get_integral_extreme-NTuple{4, Any}"><code>DOLPHYN.get_integral_extreme</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_integral_extreme(GDF, statKey, col_names, ConstCols)</code></pre><p>Get the period index with the minimum or maximum load or capacity factor summed over the period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L383-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.get_load_multipliers" href="#DOLPHYN.get_load_multipliers"><code>DOLPHYN.get_load_multipliers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_load_multipliers(ClusterOutputData, ModifiedData, M, W, LoadCols, TimestepsPerRepPeriod, NewColNames, NClusters, Ncols)</code></pre><p>Get multipliers to linearly scale clustered load profiles L zone-wise such that their weighted sum equals the original zonal total load. Scale load profiles later using these multipliers in order to ensure that a copy of the original load is kept for validation.</p><p>Find <span>$k_z$</span> such that:</p><p class="math-container">\[\sum_{i \in I} L_{i,z} = \sum_{t \in T, m \in M} C_{t,m,z} \cdot \frac{w_m}{T} \cdot k_z   \: \: \: \forall z \in Z\]</p><p>where <span>$Z$</span> is the set of zones, <span>$I$</span> is the full time domain, <span>$T$</span> is the length of one period (e.g., 168 for one week in hours), <span>$M$</span> is the set of representative periods, <span>$L_{i,z}$</span> is the original zonal load profile over time (hour) index <span>$i$</span>, <span>$C_{i,m,z}$</span> is the load in timestep <span>$i$</span> for representative period <span>$m$</span> in zone <span>$z$</span>, <span>$w_m$</span> is the weight of the representative period equal to the total number of hours that one hour in representative period <span>$m$</span> represents in the original profile, and <span>$k_z$</span> is the zonal load multiplier returned by the function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L445-L463">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.get_worst_period_idx-Tuple{Any}" href="#DOLPHYN.get_worst_period_idx-Tuple{Any}"><code>DOLPHYN.get_worst_period_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_worst_period_idx(R)</code></pre><p>Get the index of the period that is farthest from its representative period by Euclidean distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L241-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_flexible_demand-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_flexible_demand-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_flexible_demand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_flexible_demand(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function defines the operating constraints for flexible demand resources. As implemented, flexible demand resources (<span>$y \in \mathcal{DF}$</span>) are characterized by: a) maximum deferrable demand as a fraction of available capacity in a particular time step <span>$t$</span>, <span>$\rho^{max}_{y,z,t}$</span>, b) the maximum time this demand can be advanced and delayed, defined by parameters, <span>$\tau^{advance}_{y,z}$</span> and <span>$\tau^{delay}_{y,z}$</span>, respectively and c) the energy losses associated with shifting demand, <span>$\eta_{y,z}^{dflex}$</span>.</p><p><strong>Tracking total deferred demand</strong></p><p>The operational constraints governing flexible demand resources are as follows.</p><p>The first two constraints model keep track of inventory of deferred demand in each time step.  Specifically, the amount of deferred demand remaining to be served (<span>$\Gamma_{y,z,t}$</span>) depends on the amount in the previous time step minus the served demand during time step <span>$t$</span> (<span>$\Theta_{y,z,t}$</span>) while accounting for energy losses associated with demand flexibility, plus the demand that has been deferred during the current time step (<span>$\Pi_{y,z,t}$</span>). Note that variable <span>$\Gamma_{y,z,t} \in \mathbb{R}$</span>, <span>$\forall y \in \mathcal{DF}, t  \in \mathcal{T}$</span>. Similar to hydro inventory or storage state of charge constraints, for the first time step of the year (or each representative period), we define the deferred demand level based on level of deferred demand in the last time step of the year (or each representative period).</p><p class="math-container">\[\begin{aligned}
\Gamma_{y,z,t} = \Gamma_{y,z,t-1} -\eta_{y,z}^{dflex}\Theta_{y,z,t} +\Pi_{y,z,t} \hspace{4 cm}  \forall y \in \mathcal{DF}, z \in \mathcal{Z}, t \in \mathcal{T}^{interior} \\
\Gamma_{y,z,t} = \Gamma_{y,z,t +\tau^{period}-1} -\eta_{y,z}^{dflex}\Theta_{y,z,t} +\Pi_{y,z,t} \hspace{4 cm}  \forall y \in \mathcal{DF}, z \in \mathcal{Z}, t \in \mathcal{T}^{start}
\end{aligned}\]</p><p><strong>Bounds on available demand flexibility</strong></p><p>At any given time step, the amount of demand that can be shifted or deferred cannot exceed the maximum deferrable demand, defined by product of the availability factor (<span>$\rho^{max}_{y,t}$</span>) times the available capacity(<span>$\Delta^{total}_{y,z}$</span>).</p><p class="math-container">\[\begin{aligned}
\Pi_{y,t} \leq \rho^{max}_{y,z,t}\Delta_{y,z} \hspace{4 cm}  \forall y \in \mathcal{DF}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p><strong>Maximum time delay and advancements</strong></p><p>Delayed demand must then be served within a fixed number of time steps. This is done by enforcing the sum of demand satisfied (<span>$\Theta_{y,z,t}$</span>) in the following <span>$\tau^{delay}_{y,z}$</span> time steps (e.g., t + 1 to t + <span>$\tau^{delay}_{y,z}$</span>) to be greater than or equal to the level of energy deferred during time step <span>$t$</span>.</p><p class="math-container">\[\begin{aligned}
\sum_{e=t+1}^{t+\tau^{delay}_{y,z}}{\Theta_{y,z,e}} \geq \Gamma_{y,z,t}
    \hspace{4 cm}  \forall y \in \mathcal{DF},z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>A similar constraints maximum time steps of demand advancement. This is done by enforcing the sum of demand deferred (<span>$\Pi_{y,t}$</span>) in the following <span>$\tau^{advance}_{y}$</span> time steps (e.g., t + 1 to t + <span>$\tau^{advance}_{y}$</span>) to be greater than or equal to the total level of energy deferred during time <span>$t$</span> (-<span>$\Gamma_{y,t}$</span>). The negative sign is included to account for the established sign convention that treat demand deferred in advance of the actual demand is defined to be negative.</p><p class="math-container">\[\begin{aligned}
\sum_{e=t+1}^{t+\tau^{advance}_{y,z}}{\Pi_{y,z,e}} \geq -\Gamma_{y,z,t}
    \hspace{4 cm}  \forall y \in \mathcal{DF}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>If <span>$t$</span> is first time step of the year (or the first time step of the representative period), then the above two constraints are implemented to look back over the last n time steps, starting with the last time step of the year (or the last time step of the representative period). This time-wrapping implementation is similar to the time-wrapping implementations used for defining the storage balance constraints for hydropower reservoir resources and energy storage resources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/flexible_demand/h2_flexible_demand.jl#L17-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_long_duration_storage-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.h2_long_duration_storage-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.h2_long_duration_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_long_duration_storage(EP::Model, inputs::Dict)</code></pre><p>This function creates variables and constraints enabling modeling of long duration storage resources when modeling representative time periods.</p><p><strong>Storage inventory balance at beginning of each representative period</strong></p><p>The constraints in this section are used to approximate the behavior of long-duration energy storage technologies when approximating annual grid operations by modeling operations over representative periods. Previously, the state of charge balance for storage (as defined in <code>storage_all()</code>) assumed that state of charge at the beginning and end of each representative period has to be the same. In other words, the amount of energy built up or consumed by storage technology <span>$o$</span> in zone <span>$z$</span> over the representative period <span>$m$</span>, <span>$\Delta Q_{o,z,m} = 0$</span>. This assumption implicitly excludes the possibility of transferring energy from one representative period to the other which could be cost-optimal when the capital cost of energy storage capacity is relatively small. To model long-duration energy storage using representative periods, we replace the state of charge equation, such that the first term on the right hand side accounts for change in storage inventory associated with representative period <span>$m$</span> (<span>$\Delta Q_{o,z,m}$</span>), which could be positive (net accumulation) or negative (net reduction).</p><p class="math-container">\[\begin{aligned}
&amp; \Gamma_{o,z,(m-1)\times \tau^{period}+1 } =\left(1-\eta_{o,z}^{loss}\right)\times \left(\Gamma_{o,z,m\times \tau^{period}} -\Delta Q_{o,z,m}\right) -  \\
&amp; \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,(m-1)\times \tau^{period}+1} + \eta_{o,z}^{charge}\Pi_{o,z,(m-1)\times \tau^{period}+1} \quad \forall o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, m \in \mathcal{M}
\end{aligned}\]</p><p>By definition <span>$\mathcal{T}^{start}=\{\left(m-1\right) \times \tau^{period}+1 | m \in \mathcal{M}\}$</span>, which implies that this constraint is defined for all values of <span>$t \in T^{start}$</span>.</p><p><strong>Storage inventory change input periods</strong></p><p>We need additional variables and constraints to approximate energy exchange between representative periods, while accounting for their chronological occurence in the original input time series data and the possibility that two representative periods may not be adjacent to each other (see Figure below). To implement this, we introduce a new variable <span>$Q_{o,z, n}$</span> that models inventory of storage technology <span>$o \in O$</span> in zone <span>$z$</span> in each input period <span>$n \in \mathcal{N}$</span>. Additionally we define a function mapping, <span>$f: n \rightarrow m$</span>, that uniquely maps each input period <span>$n$</span> to its corresponding representative period <span>$m$</span>. This mapping is available as an output of the process used to identify representative periods (E.g. k-means clustering <a href="https://www.sciencedirect.com/science/article/pii/S0360544218315238?casa_token=I-6GVNMtAVIAAAAA:G8LFXFqXxRGrXHtrzmiIGm02BusIUmm83zKh8xf1BXY81-dTnA9p2YI1NnGuzlYBXsxK12by">Mallapragada et al., 2018</a>).</p><p><img src="../assets/LDES_approach.png" alt="Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations"/> <em>Figure. Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations</em></p><p>The following two equations define the storage inventory at the beginning of each input period <span>$n+1$</span> as the sum of storage inventory at begining of previous input period <span>$n$</span> plus change in storage inventory for that period. The latter is approximated by the change in storage inventory in the corresponding representative period, identified per the mapping <span>$f(n)$</span>.  The second constraint relates the storage level of the last input period, <span>$|N|$</span>, with the storage level at the beginning of the first input period. Finally, if the input period is also a representative period, then a third constraint enforces that initial storage level estimated by the intra-period storage balance constraint should equal the initial storage level estimated from the inter-period storage balance constraints. Note that <span>$|N|$</span> refers to the last modeled period.</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,n+1} = Q_{o,z,n} + \Delta Q_{o,z,f(n)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in \mathcal{N}\setminus\{|N|\}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,1} = Q_{o,z,|N|} + \Delta Q_{o,z,f(|N|)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n = |N|
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,n} =\Gamma_{o,z,f(n)\times \tau^{period}} - \Delta Q_{o,z,m}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in   \mathcal{N}^{rep},
\end{aligned}\]</p><p>Finally, the next constraint enforces that the initial storage level for each input period <span>$n$</span> must be less than the installed energy capacity limit. This constraint ensures that installed energy storage capacity is consistent with the state of charge during both the operational time periods <span>$t$</span> during each sample period <span>$m$</span> as well as at the start of each chronologically ordered input period <span>$n$</span> in the full annual time series.</p><p class="math-container">\[\begin{aligned}
	Q_{o,z,n} \leq \Delta^{total, energy}_{o,z}
\quad \forall n \in \mathcal{N}, o \in \mathcal{O}^{LDES}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/storage/h2_long_duration_storage.jl#L17-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_long_duration_truck-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.h2_long_duration_truck-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.h2_long_duration_truck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_long_duration_truck(EP::Model, inputs::Dict)</code></pre><p>This function includes LongDurationtruck only when modeling representative periods.</p><p>** Variables**</p><p>State of charge of truck at beginning of each modeled period n. \begin{align}     v<em>{j, t}^{\mathrm{F}}+v</em>{j, t}^{\mathrm{E}} &amp; = V_{j} \quad \forall j \in \mathbb{J}, t \in \mathbb{T} \end{align}</p><p class="math-container">\[\begin{aligned}
    v_{n}^{SOC} \geqslant 0,v_{z,j,n}^{SOC}\leqslant v_{j}^{TRU}
\end{aligned}\]</p><p><strong>Constraints</strong></p><p>State of charge of truck at beginning of each modeled period cannot exceed installed energy capacity</p><p class="math-container">\[\begin{aligned}
    v_{z,j,n}^{SOC}&lt; v_{j}^{TRU}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/truck/h2_long_duration_truck.jl#L17-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_non_served_energy-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_non_served_energy-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_non_served_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_non_served_energy(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function defines the non-served hydrogen/curtailed hydrogen demand decision variable <span>$\Lambda_{s,t,z} \forall s \in \mathcal{S}, \forall t \in \mathcal{T}, z \in \mathcal{Z}$</span>, representing the total amount of demand curtailed in demand segment <span>$s$</span> at time period <span>$t$</span> in zone <span>$z$</span>. The first segment of non-served energy, <span>$s=1$</span>, is used to denote the cost of involuntary demand curtailment (e.g. emergency load shedding or rolling blackouts), specified as the value of <span>$n_{1}^{slope}$</span>. Additional segments, <span>$s \geq 2$</span> can be used to specify a segment-wise approximation of a price elastic demand curve, or segments of price-responsive curtailable loads (aka demand response). Each segment denotes a price/cost at which the segment of demand is willing to curtail consumption, <span>$n_{s}^{slope}$</span>, representing the marginal willingness to pay for electricity of this segment of demand (or opportunity cost incurred when demand is not served) and a maximum quantity of demand in this segment, <span>$n_{s}^{size}$</span>, specified as a share of demand in each zone in each time step, <span>$D_{t,z}.$</span> Note that the current implementation assumes demand segments are an equal share of hourly load in all zones.</p><p>This function defines contributions to the objective function from the cost of non-served energy/curtailed demand from all demand curtailment segments <span>$s \in \mathcal{S}$</span> over all time periods <span>$t \in \mathcal{T}$</span> and all zones <span>$z \in \mathcal{Z}$</span>:</p><p class="math-container">\[\begin{aligned}
	Obj_{NSE} =
	\sum_{s \in \mathcal{S} } \sum_{t \in \mathcal{T}} \sum_{z \in \mathcal{Z}}\omega_{t} \times n_{s}^{slope} \times \Lambda_{s,t,z}
\end{aligned}\]</p><p>Contributions to the power balance expression from non-served energy/curtailed demand from each demand segment <span>$s \in \mathcal{S}$</span> are also defined as:</p><p class="math-container">\[\begin{aligned}
	PowerBal_{NSE} =
	\sum_{s \in \mathcal{S} } \Lambda_{s,t,z}
		\hspace{4 cm}  \forall s \in \mathcal{S}, t \in \mathcal{T}
\end{aligned}\]</p><p><strong>Bounds on curtailable demand</strong></p><p>Demand curtailed in each segment of curtailable demands <span>$s \in \mathcal{S}$</span> cannot exceed maximum allowable share of demand:</p><p class="math-container">\[\begin{aligned}
	\Lambda_{s,t,z} \leq (n_{s}^{size} \times D_{t,z})
	\hspace{4 cm}  \forall s \in \mathcal{S}, t \in \mathcal{T}, z\in \mathcal{Z}
\end{aligned}\]</p><p>Additionally, total demand curtailed in each time step cannot exceed total demand:</p><p class="math-container">\[\begin{aligned}
	\sum_{s \in \mathcal{S} } \Lambda_{s,t,z} \leq D_{t,z}
	\hspace{4 cm}  \forall t \in \mathcal{T}, z\in \mathcal{Z}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/core/h2_non_served.jl#L17-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_outputs-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_outputs-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_outputs(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This module defines the production decision variable  representing hydrogen injected into the network by resource <span>$y$</span> by at time period <span>$t$</span>.</p><p>This module additionally defines contributions to the objective function from variable costs of generation (variable O&amp;M plus fuel cost) from all resources over all time periods.</p><p><strong>Variables</strong></p><p class="math-container">\[\begin{aligned}
	Obj_{Var\_gen} =
	\sum_{y \in \mathcal{G} } \sum_{t \in \mathcal{T}}\omega_{t}\times(\pi^{VOM}_{y} + \pi^{FUEL}_{y})\times \Theta_{y,t}
\end{aligned}\]</p><p><strong>Expressions</strong></p><p class="math-container">\[\begin{aligned}
	\varepsilon _{OUT}^{GEN} =
		\Omega _{t} \times \xi _{k}^{OMCostPTone} {\div} ModelScalingFactors^{2}+ FuelCost   
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\varepsilon _{CH2GenVarOutT}^{Total} =\sum_{t}^{t\to t^{&#39;} } \sum_{k}^{ \mathbb{K}} \varepsilon _{k,t}^{GenOut}    
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\varepsilon _{CH2GenVarOut}^{Total} =\sum_{t}^{t\to t^{&#39;} } \varepsilon _{t}^{GenOut}      
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/core/h2_outputs.jl#L17-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_pipeline-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_pipeline-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_pipeline(EP::Model, inputs::Dict, setup::Dict)

This function includes the variables, expressions and objective funtion of pipeline.

This function expresses H2 change at zone z through pipeline i between two zones and can be split into H2 delivering and flowing out.</code></pre><p class="math-container">\[\begin{aligned}
    C_{\mathrm{PIP}}^{\mathrm{c}}=\delta_{i}^{\mathrm{PIP}} \sum_{z \rightarrow z^{\prime} \in \mathbb{B}} \sum_{i \in \mathbb{I}} \mathrm{c}_{i}^{\mathrm{PIP}} \mathrm{L}_{z \rightarrow z^{\prime}} l_{z \rightarrow z,,^{\prime} i}
    h_{z \rightarrow z,^{\prime}i, t}^{\mathrm{PIP}}=h_{z \rightarrow z,^{\prime}i, t}^{\mathrm{PIP+}}-h_{z \rightarrow z,{ }^{\prime} i, t}^{\mathrm{PIP-}} \quad \forall z \rightarrow z^{\prime} \in \mathbb{B}, i \in \mathbb{I}, t \in \mathbb{T}
\end{aligned}    
 ```

    The flow rate of H2 through pipeline type i is capped by the operational limits of the pipeline, multiplied by the number of constructed pipeline i\]</p><p>math \begin{aligned}     \overline{\mathrm{F}}<em>{i} l</em>{z \rightarrow z,^{\prime} i} \geq h<em>{z \rightarrow z,{ }^{\prime}, t}^{\mathrm{PIP+}}, h</em>{z \rightarrow z,{ }^{\prime} i, t}^{\mathrm{PIP}} \geq 0 \quad \forall z \rightarrow z^{\prime} \in \mathbb{B}, i \in \mathbb{I}, t \in \mathbb{T} \end{aligned}    </p><pre><code class="nohighlight hljs">
    The pipeline has storage capacity via line packing:</code></pre><p>math \begin{aligned}     \overline{\mathrm{E}}<em>{i}^{\mathrm{PIP}} l</em>{z \rightarrow z,^{\prime} i} \geq &amp;-\sum<em>{\tau=t</em>{0}}^{t}\left(h<em>{z^{\prime} \rightarrow z, i, \tau}^{\mathrm{PIP}}+h</em>{z \rightarrow z,^{\prime} i, \tau}^{\mathrm{PIP}}\right) \Delta t \geq \underline{\mathrm{R}}<em>{i}^{\mathrm{PIP}} \overline{\mathrm{E}}</em>{i}^{\mathrm{PIP}} l_{z \rightarrow z,^{\prime} i} \
    &amp; \forall z^{\prime} \in \mathbb{Z}, z \in \mathbb{Z}, i \in \mathbb{I}, t \in \mathbb{T} \end{aligned}    ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/transmission/h2_pipeline.jl#L20-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_production-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_production-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_production</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_production(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This module creates decision variables, expressions, and constraints related to various hydrogen generation technologies (electrolyzers, natural gas reforming etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/generation/h2_production.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_production_all-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_production_all-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_production_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_production_all(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>The h2 generation module creates decision variables, expressions, and constraints related to hydrogen generation infrastructure</p><p>This module uses the following &#39;helper&#39; functions in separate files: <code>h2_generation_commit()</code> for resources subject to unit commitment decisions and constraints (if any) and <code>h2_generation_no_commit()</code> for resources not subject to unit commitment (if any).</p><ul><li>Investment and FOM cost expression, VOM cost expression, minimum and maximum capacity limits</li></ul><p><strong>Constraints</strong> The outputs of each type of H2 generation facilities have to be kept within their lower and upper bounds. q</p><p class="math-container">\[\begin{aligned}
	\overline{\mathrm{R}}_{k, z}^{\mathrm{GEN}} \mathrm{M}_{k, z}^{\mathrm{GEN}} n_{k, z, t} \geq h_{k, z, t}^{\mathrm{GEN}} \geq \underline{\mathrm{R}}_{k, z}^{\mathrm{GEN}} \mathbf{M}_{k, z}^{\mathrm{GEN}} n_{k, z, t} \\
	\forall k \in \mathbb{K}, z \in \mathbb{Z}, t \in \mathbb{T}
\end{aligned}\]</p><p>The number of online units has to be less than the available number of generation units.</p><p class="math-container">\[\begin{aligned}
	n_{k, z, t} \leq N_{k, z} \quad \forall k \in \mathbb{K}, z \in \mathbb{Z}, t \in \mathbb{T}
\end{aligned}\]</p><p>There are limits on the period of time between when a unit starts up and when it can be shut-down again, and vice versa</p><p class="math-container">\[\begin{aligned}
	n_{k, z, t} \geq \sum_{\tau=t-\tau_{k, z}^{\mathrm{UP}}}^{t} n_{k, z, t}^{\mathrm{UP}} \quad \forall k \in \mathbb{K}, z \in \mathbb{Z}, t \in \mathbb{T}
	N_{k, z}-n_{k, z, t} \geq \sum_{\tau=t-\tau_{k, z}^{\mathrm{DOWN}}}^{t} n_{k, z, t}^{\mathrm{DOWN}} \quad \forall k \in \mathbb{K}, z \in \mathbb{Z}, t \in \mathbb{T}
\end{aligned}\]</p><p><strong>Expressions</strong> The numbers of units starting up and shutting down are modeled as:</p><p class="math-container">\[\begin{aligned}
	n_{k, z, t}-n_{k, z, t-1}=n_{k, z, t}^{\mathrm{UP}}-n_{k, z, t}^{\mathrm{DOWN}} \quad \forall k \in \mathbb{K}, z \in \mathbb{Z}, t \in \mathbb{T}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/generation/h2_production_all.jl#L17-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_production_commit-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_production_commit-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_production_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_production_commit(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>The h2_generation module creates decision variables, expressions, and constraints related to various hydrogen generation technologies with unit commitment constraints (e.g. natural gas reforming etc.)</p><p>Documentation to follow ******</p><p><strong>Power balance expression</strong></p><p>This function adds the sum of power generation from thermal units subject to unit commitment (<span>$\Theta_{y \in UC,t \in T,z \in Z}$</span>) to the power balance expression.</p><p><strong>Startup and shutdown events (thermal plant cycling)</strong></p><p><em>Capacitated limits on unit commitment decision variables</em></p><p>Thermal resources subject to unit commitment (<span>$y \in \mathcal{UC}$</span>) adhere to the following constraints on commitment states, startup events, and shutdown events, which limit each decision to be no greater than the maximum number of discrete units installed (as per the following three constraints):</p><p class="math-container">\[\begin{aligned}
\nu_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\chi_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\zeta_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 1-3 in the code)</p><p>where decision <span>$\nu_{y,z,t}$</span> designates the commitment state of generator cluster <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>, decision <span>$\chi_{y,z,t}$</span> represents number of startup decisions, decision <span>$\zeta_{y,z,t}$</span> represents number of shutdown decisions, <span>$\Delta^{\text{total}}_{y,z}$</span> is the total installed capacity, and parameter <span>$\Omega^{size}_{y,z}$</span> is the unit size.</p><p><em>Commitment state constraint linking start-up and shut-down decisions</em></p><p>Additionally, the following constarint maintains the commitment state variable across time, <span>$\nu_{y,z,t}$</span>, as the sum of the commitment state in the prior, <span>$\nu_{y,z,t-1}$</span>, period plus the number of units started in the current period, <span>$\chi_{y,z,t}$</span>, less the number of units shut down in the current period, <span>$\zeta_{y,z,t}$</span>:</p><p class="math-container">\[\begin{aligned}
&amp;\nu_{y,z,t} =\nu_{y,z,t-1} + \chi_{y,z,t} - \zeta_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}^{interior} \\
&amp;\nu_{y,z,t} =\nu_{y,z,t +\tau^{period}-1} + \chi_{y,z,t} - \zeta_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}^{start}
\end{aligned}\]</p><p>(See Constraint 4 in the code)</p><p>Like other time-coupling constraints, this constraint wraps around to link the commitment state in the first time step of the year (or each representative period), <span>$t \in \mathcal{T}^{start}$</span>, to the last time step of the year (or each representative period), <span>$t+\tau^{period}-1$</span>.</p><p><strong>Ramping constraints</strong></p><p>Thermal resources subject to unit commitment (<span>$y \in UC$</span>) adhere to the following ramping constraints on hourly changes in power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t-1} - \Theta_{y,z,t} &amp;\leq  \kappa^{down}_{y,z} \cdot \Omega^{size}_{y,z} \cdot (\nu_{y,z,t} - \chi_{y,z,t}) &amp; \\[6pt]
	\qquad &amp; - \: \rho^{min}_{y,z} \cdot \Omega^{size}_{y,z} \cdot \chi_{y,z,t} &amp; \hspace{0.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  \\[6pt]
	\qquad &amp; + \: \text{min}( \rho^{max}_{y,z,t}, \text{max}( \rho^{min}_{y,z}, \kappa^{down}_{y,z} ) ) \cdot \Omega^{size}_{y,z} \cdot \zeta_{y,z,t} &amp;
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} - \Theta_{y,z,t-1} &amp;\leq  \kappa^{up}_{y,z} \cdot \Omega^{size}_{y,z} \cdot (\nu_{y,z,t} - \chi_{y,z,t}) &amp; \\[6pt]
	\qquad &amp; + \: \text{min}( \rho^{max}_{y,z,t}, \text{max}( \rho^{min}_{y,z}, \kappa^{up}_{y,z} ) ) \cdot \Omega^{size}_{y,z} \cdot \chi_{y,z,t} &amp; \hspace{0.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} \\[6pt]
	\qquad &amp; - \: \rho^{min}_{y,z} \cdot \Omega^{size}_{y,z} \cdot \zeta_{y,z,t} &amp;
\end{aligned}\]</p><p>(See Constraints 5-6 in the code)</p><p>where decision <span>$\Theta_{y,z,t}$</span> is the energy injected into the grid by technology <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>, parameter <span>$\kappa_{y,z,t}^{up|down}$</span> is the maximum ramp-up or ramp-down rate as a percentage of installed capacity, parameter <span>$\rho_{y,z}^{min}$</span> is the minimum stable power output per unit of installed capacity, and parameter <span>$\rho_{y,z,t}^{max}$</span> is the maximum available generation per unit of installed capacity. These constraints account for the ramping limits for committed (online) units as well as faster changes in power enabled by units starting or shutting down in the current time step.</p><p><strong>Minimum and maximum power output</strong></p><p>If not modeling regulation and spinning reserves, thermal resources subject to unit commitment adhere to the following constraints that ensure power output does not exceed minimum and maximum feasible levels:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{min}_{y,z} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{max}_{y,z} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 7-8 the code)</p><p>If modeling reserves and regulation, these constraints are replaced by those established in this <code>thermal_commit_reserves()</code>.</p><p><strong>Minimum and maximum up and down time</strong></p><p>Thermal resources subject to unit commitment adhere to the following constraints on the minimum time steps after start-up before a unit can shutdown again (minimum up time) and the minimum time steps after shut-down before a unit can start-up again (minimum down time):</p><p class="math-container">\[\begin{aligned}
	\nu_{y,z,t} \geq \displaystyle \sum_{\hat{t} = t-\tau^{up}_{y,z}}^t \chi_{y,z,\hat{t}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\frac{\overline{\Delta_{y,z}} + \Omega_{y,z} - \Delta_{y,z}}{\Omega^{size}_{y,z}} -  \nu_{y,z,t} \geq \displaystyle \sum_{\hat{t} = t-\tau^{down}_{y,z}}^t \zeta_{y,z,\hat{t}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 9-10 in the code)</p><p>where <span>$\tau_{y,z}^{up|down}$</span> is the minimum up or down time for units in generating cluster <span>$y$</span> in zone <span>$z$</span>.</p><p>Like with the ramping constraints, the minimum up and down constraint time also wrap around from the start of each time period to the end of each period. It is recommended that users of GenX must use longer subperiods than the longest min up/down time if modeling UC. Otherwise, the model will report error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/generation/h2_production_commit.jl#L17-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_production_no_commit-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_production_no_commit-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_production_no_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_production_no_commit(EP::Model, inputs::Dict,setup::Dict)</code></pre><p>The h2_generation module creates decision variables, expressions, and constraints related to various hydrogen generation technologies (electrolyzers, natural gas reforming etc.) without unit commitment constraints</p><p><strong>Ramping limits</strong></p><p>Thermal resources not subject to unit commitment (<span>$y \in H \setminus UC$</span>) adhere instead to the following ramping limits on hourly changes in power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t-1} - \Theta_{y,z,t} \leq \kappa_{y,z}^{down} \Delta^{\text{total}}_{y,z} \hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} - \Theta_{y,z,t-1} \leq \kappa_{y,z}^{up} \Delta^{\text{total}}_{y,z} \hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 1-2 in the code)</p><p>This set of time-coupling constraints wrap around to ensure the power output in the first time step of each year (or each representative period), <span>$t \in \mathcal{T}^{start}$</span>, is within the eligible ramp of the power output in the final time step of the year (or each representative period), <span>$t+\tau^{period}-1$</span>.</p><p><strong>Minimum and maximum power output</strong></p><p>When not modeling regulation and reserves, thermal units not subject to unit commitment decisions are bound by the following limits on maximum and minimum power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{min}_{y,z} \times \Delta^{total}_{y,z}
	\hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Delta^{total}_{y,z}
	\hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/generation/h2_production_no_commit.jl#L17-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_storage-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_storage-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_storage(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>A wide range of energy storage devices (all <span>$o \in \mathcal{O}$</span>) can be modeled in DOLPHYN, using one of two generic storage formulations: (1) storage technologies with symmetric charge and discharge capacity (all <span>$o \in \mathcal{O}^{sym}$</span>), such as Lithium-ion batteries and most other electrochemical storage devices that use the same components for both charge and discharge; and (2) storage technologies that employ distinct and potentially asymmetric charge and discharge capacities (all <span>$o \in \mathcal{O}^{asym}$</span>), such as most thermal storage technologies or hydrogen electrolysis/storage/fuel cell or combustion turbine systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/storage/h2_storage.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_storage_all-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_storage_all-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_storage_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_storage_all(EP::Model, inputs::Dict, setup::Dict)

Sets up variables and constraints common to all storage resources. See ```storage()``` in ```storage.jl``` for description of constraints.</code></pre><p><strong>Storage with symmetric charge and discharge capacity</strong></p><p>For storage technologies with symmetric charge and discharge capacity (all <span>$o \in \mathcal{O}^{sym}$</span>), charge rate, <span>$\Pi_{o,z,t}$</span>, is constrained by the total installed power capacity, <span>$\Omega_{o,z}$</span>. Since storage resources generally represent a `cluster&#39; of multiple similar storage devices of the same type/cost in the same zone, GenX permits storage resources to simultaneously charge and discharge (as some units could be charging while others discharge), with the simultaenous sum of charge, <span>$\Pi_{o,z,t}$</span>, and discharge, <span>$\Theta_{o,z,t}$</span>, also limited by the total installed power capacity, <span>$\Delta^{total}_{o,z}$</span>. These two constraints are as follows:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Pi_{o,z,t} + \Theta_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>These constraints are created with the function <code>storage_symmetric()</code> in <code>storage_symmetric.jl</code>.</p><p>If reserves are modeled, the following two constraints replace those above:</p><p class="math-container">\[\begin{aligned}
&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T}\\
&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} + \Theta_{o,z,t} + f^{discharge}_{o,z,t} + r^{discharge}_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T} \\
\end{aligned}\]</p><p>where <span>$f^{charge}_{o,z,t}$</span> is the contribution of storage resources to frequency regulation while charging, <span>$f^{discharge}_{o,z,t}$</span> is the contribution of storage resources to frequency regulation while discharging, and <span>$r^{discharge}_{o,z,t}$</span> is the contribution of storage resources to upward reserves while discharging. Note that as storage resources can contribute to regulation and reserves while either charging or discharging, the proxy variables <span>$f^{charge}_{o,z,t}, f^{discharge}_{o,z,t}$</span> and <span>$r^{charge}_{o,z,t}, r^{discharge}_{o,z,t}$</span> are created for storage resources where the total contribution to regulation and reserves, <span>$f_{o,z,t}, r_{o,z,t}$</span> is the sum of the proxy variables.</p><p>These constraints are created with the function <code>storage_symmetric_reserves()</code> in <code>storage_symmetric.jl</code>.</p><p><strong>Storage with asymmetric charge and discharge capacity</strong></p><p>For storage technologies with asymmetric charge and discharge capacities (all <span>$o \in \mathcal{O}^{asym}$</span>), charge rate, <span>$\Pi_{o,z,t}$</span>, is constrained by the total installed charge capacity, <span>$\Delta^{total, charge}_{o,z}$</span>, as follows:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} \leq \Delta^{total, charge}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{asym}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>These constraints are created with the function <code>storage_asymmetric()</code> in <code>storage_asymmetric.jl</code>.</p><p>If reserves are modeled, the above constraint is replaced by the following:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} \leq \Delta^{total, charge}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{asym}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>where <span>$f^{+}_{y=o,z,t}$</span> is the contribution of storage resources to frequency regulation while charging.</p><p>These constraints are created with the function <code>storage_asymmetric_reserves()</code> in <code>storage_asymmetric.jl</code>.</p><p><strong>All storage resources</strong></p><p>The following constraints apply to all storage resources, <span>$o \in \mathcal{O}$</span>, regardless of whether the charge/discharge capacities are symmetric or asymmetric.</p><p>The following two constraints track the state of charge of the storage resources at the end of each time period, relating the volume of energy stored at the end of the time period, <span>$\Gamma_{o,z,t}$</span>, to the state of charge at the end of the prior time period, <span>$\Gamma_{o,z,t-1}$</span>, the charge and discharge decisions in the current time period, <span>$\Pi_{o,z,t}, \Theta_{o,z,t}$</span>, and the self discharge rate for the storage resource (if any), <span>$\eta_{o,z}^{loss}$</span>.  The first of these two constraints enforces storage inventory balance for interior time steps <span>$(t \in \mathcal{T}^{interior})$</span>, while the second enforces storage balance constraint for the initial time step <span>$(t \in \mathcal{T}^{start})$</span>.</p><p class="math-container">\[\begin{aligned}
	&amp;  \Gamma_{o,z,t} =\Gamma_{o,z,t-1} - \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,t} + \eta_{o,z}^{charge}\Pi_{o,z,t} - \eta_{o,z}^{loss}\Gamma_{o,z,t-1}  \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}^{interior}\\
	&amp;  \Gamma_{o,z,t} =\Gamma_{o,z,t+\tau^{period}-1} - \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,t} + \eta_{o,z}^{charge}\Pi_{o,z,t} - \eta_{o,z}^{loss}\Gamma_{o,z,t+\tau^{period}-1}  \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}^{start}
\end{aligned}\]</p><p>When modeling the entire year as a single chronological period with total number of time steps of <span>$\tau^{period}$</span>, storage inventory in the first time step is linked to storage inventory at the last time step of the period representing the year. Alternatively, when modeling the entire year with multiple representative periods, this constraint relates storage inventory in the first timestep of the representative period with the inventory at the last time step of the representative period, where each representative period is made of <span>$\tau^{period}$</span> time steps. In this implementation, energy exchange between representative periods is not permitted. When modeling representative time periods, GenX enables modeling of long duration energy storage which tracks state of charge between representative periods enable energy to be moved throughout the year. If <code>LongDurationStorage=1</code> and <code>OperationWrapping=1</code>, this function calls <code>long_duration_storage()</code> in <code>long_duration_storage.jl</code> to enable this feature.</p><p>The next constraint limits the volume of energy stored at any time, <span>$\Gamma_{o,z,t}$</span>, to be less than the installed energy storage capacity, <span>$\Delta^{total, energy}_{o,z}$</span>. Finally, the maximum discharge rate for storage resources, <span>$\Pi_{o,z,t}$</span>, is constrained to be less than the discharge power capacity, <span>$\Omega_{o,z,t}$</span> or the state of charge at the end of the last period, <span>$\Gamma_{o,z,t-1}$</span>, whichever is lessor.</p><p class="math-container">\[\begin{aligned}
	&amp;  \Gamma_{o,z,t} \leq \Delta^{total, energy}_{o,z} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} \leq \Gamma_{o,z,t-1} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The above constraints are established in <code>storage_all()</code> in <code>storage_all.jl</code>.</p><p>If reserves are modeled, two pairs of proxy variables <span>$f^{charge}_{o,z,t}, f^{discharge}_{o,z,t}$</span> and <span>$r^{charge}_{o,z,t}, r^{discharge}_{o,z,t}$</span> are created for storage resources, to denote the contribution of storage resources to regulation or reserves while charging or discharging, respectively. The total contribution to regulation and reserves, <span>$f_{o,z,t}, r_{o,z,t}$</span> is then the sum of the proxy variables:</p><p class="math-container">\[\begin{aligned}
	&amp;  f_{o,z,t} = f^{charge}_{o,z,t} + f^{dicharge}_{o,z,t} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  r_{o,z,t} = r^{charge}_{o,z,t} + r^{dicharge}_{o,z,t} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The total storage contribution to frequency regulation (<span>$f_{o,z,t}$</span>) and reserves (<span>$r_{o,z,t}$</span>) are each limited specified fraction of installed discharge power capacity (<span>$\upsilon^{reg}_{y,z}, \upsilon^{rsv}_{y,z}$</span>), reflecting the maximum ramp rate for the storage resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.</p><p class="math-container">\[\begin{aligned}
	f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \Delta^{total}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T} \\
	r_{y,z, t} \leq \upsilon^{rsv}_{y,z}\times \Delta^{total}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>When charging, reducing the charge rate is contributing to upwards reserve and frequency regulation as it drops net demand. As such, the sum of the charge rate plus contribution to regulation and reserves up must be greater than zero. Additionally, the discharge rate plus the contribution to regulation must be greater than zero.</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} - f^{charge}_{o,z,t} - r^{charge}_{o,z,t} \geq 0 &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} - f^{discharge}_{o,z,t} \geq 0 &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>Additionally, when reserves are modeled, the maximum charge rate and contribution to regulation while charging can be no greater than the available energy storage capacity, or the difference between the total energy storage capacity, <span>$\Delta^{total, energy}_{o,z}$</span>, and the state of charge at the end of the previous time period, <span>$\Gamma_{o,z,t-1}$</span>. Note that for storage to contribute to reserves down while charging, the storage device must be capable of increasing the charge rate (which increase net load).</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} \leq \Delta^{energy, total}_{o,z} - \Gamma_{o,z,t-1} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>Finally, the constraints on maximum discharge rate are replaced by the following, to account for capacity contributed to regulation and reserves:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Theta_{o,z,t} + f^{discharge}_{o,z,t} + r^{discharge}_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} + f^{discharge}_{o,z,t} + r^{discharge}_{o,z,t} \leq \Gamma_{o,z,t-1} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The above reserve related constraints are established by <code>storage_all_reserves()</code> in <code>storage_all.jl</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/storage/h2_storage_all.jl#L17-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_storage_investment-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_storage_investment-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_storage_investment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_storage_investment(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This module defines the  decision variable  representing charging and energy components of hydrogen storage technologies</p><p>The total capacity of each resource is defined as the sum of the existing capacity plus the newly invested capacity minus any retired capacity.</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total,energy}_{y,z} =(\overline{\Delta^{energy}_{y,z}}+\Omega^{energy}_{y,z}-\Delta^{energy}_{y,z}) \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}\]</p><p>One cannot retire more capacity than existing capacity.</p><p class="math-container">\[\begin{aligned}
&amp;\Delta^{energy}_{y,z} \leq \overline{\Delta^{energy}_{y,z}}
		\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}\]</p><p>For resources where <span>$\overline{\Omega_{y,z}^{energy}}$</span> and <span>$\underline{\Omega_{y,z}^{energy}}$</span> is defined, then we impose constraints on minimum and maximum power capacity.</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total,energy}_{y,z} \leq \overline{\Omega}^{energy}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z} \\
&amp; \Delta^{total,energy}_{y,z}  \geq \underline{\Omega}^{energy}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}\]</p><p>In addition, this function adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function:</p><p class="math-container">\[\begin{aligned}
&amp; 	\sum_{y \in \mathcal{O} } \sum_{z \in \mathcal{Z}}
	\left( (\pi^{INVEST,energy}_{y,z} \times    \Omega^{energy}_{y,z})
	+ (\pi^{FOM,energy}_{y,z} \times  \Delta^{total,energy}_{y,z})\right)
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/storage/h2_storage_investment.jl#L17-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_truck-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_truck-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_truck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_truck(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function includes three parts of the Truck Model.The details can be found seperately in&quot;h2<em>truck</em>investment.jl&quot; &quot;h2<em>long</em>duration<em>truck.jl&quot;and &quot;h2</em>truck_all.jl&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/truck/h2_truck.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_truck_all-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_truck_all-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_truck_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_truck_all(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function defines a series of operationg variables,expresstions and constraints in truck scheduling and routing model.</p><p><strong>Variables</strong></p><p>The sum of full and empty trucks should equal the total number of invested trucks.</p><p class="math-container">\[\begin{aligned}
    v_{j, t}^{\mathrm{F}}+v_{j, t}^{\mathrm{E}}=V_{j} \quad \forall j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}    \]</p><p>The full (empty) trucks include full (empty) trucks in transit and staying at each zones.</p><p class="math-container">\[\begin{aligned}
    v_{j, t}^{\mathrm{F}}=\sum_{z \rightarrow z^{\prime} \in \mathbb{B}} u_{z \rightarrow z, \prime^{\prime}, t}^{\mathrm{F}}+\sum_{z \in \mathbb{Z}} q_{z, j, t}^{\mathrm{F}} \\
    v_{j, t}^{\mathrm{E}}=\sum_{z \rightarrow z^{\prime} \in \mathbb{B}} u_{z \rightarrow z,,^{\prime}, t}^{\mathrm{E}}+\sum_{z \in \mathbb{Z}} q_{z, j, t}^{\mathrm{E}} \quad \forall j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}    \]</p><p><strong>Expressions</strong></p><p>The change of the total number of full (empty) available trucks at zone z should equal the number of charged (discharged) trucks minus the number of discharged (charged) trucks at zone z plus the number of full (empty) trucks that just arrived minus the number of full (empty) trucks that just departed:</p><p class="math-container">\[{\begin{aligned}
    q_{z, j, t}^{\mathrm{F}}-q_{z, j, t-1}^{\mathrm{F}}=&amp; q_{z, j, t}^{\mathrm{CHA}}-q_{z, j, t}^{\mathrm{DIS}} \\
    &amp;+\sum_{z^{\prime} \in \mathbb{Z}}\left(-x_{z \rightarrow z,{ }^{\prime} j, t-1}^{\mathrm{F}}+y_{z \rightarrow z, j, t-1}^{\mathrm{F}}\right) \\
    q_{z, j, t}^{\mathrm{E}}-q_{z, j, t-1}^{\mathrm{E}}=&amp;-q_{z, j, t}^{\mathrm{CHA}}+q_{z, j, t}^{\mathrm{DIS}} \\
    &amp;+\sum_{z^{\prime} \in \mathbb{Z}}\left(-x_{z \rightarrow z,,^{\prime} j, t-1}^{\mathrm{E}}+y_{z \rightarrow z,,^{\prime} j, t-1}^{\mathrm{E}}\right) \\
    \forall z \in \mathbb{Z}, j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}\]</p><p>The change of the total number of full (empty) trucks in transit from zone z to zone zz should equal the number of full (empty) trucks that just departed from zone z minus the number of full (empty) trucks that just arrived at zone zz:</p><p class="math-container">\[\begin{aligned}
    u_{z \rightarrow z,{ }^{\prime} j, t}^{\mathrm{F}}-u_{z \rightarrow z,{ }^{\prime} j, t-1}^{\mathrm{F}} &amp; =x_{z \rightarrow z,{ }^{\prime} j, t-1}^{\mathrm{F}}-y_{z \rightarrow z,{ }^{\prime} j, t-1}^{\mathrm{F}} \\
    u_{z \rightarrow z,{ }^{\prime} j, t}^{\mathrm{E}}-u_{z \rightarrow z,{ }^{\prime} j, t-1}^{\mathrm{E}} &amp; =x_{z \rightarrow z,^{\prime} j, t-1}^{\mathrm{E}}-y_{z \rightarrow z,{ }^{\prime} j, t-1}^{\mathrm{E}} \\
    &amp; \forall z \rightarrow z^{\prime} \in \mathbb{B}, j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}    \]</p><p>The amount of H2 delivered to zone z should equal the truck capacity times the number of discharged trucks minus the number of charged trucks, adjusted by theH2 boil-off loss during truck transportation and compression.</p><p class="math-container">\[\begin{aligned}
    h_{z, j, t}^{\mathrm{TRU}}=\left[\left(1-\sigma_{j}\right) q_{z, j, t}^{\mathrm{DIS}}-q_{z, j, t}^{\mathrm{CHA}}\right] \overline{\mathrm{E}}_{j}^{\mathrm{TRU}} \\
    \forall z \rightarrow z^{\prime} \in \mathbb{B}, j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}    \]</p><p>The minimum travelling time delay is modelled as follows.</p><p class="math-container">\[\begin{aligned}
    u_{z \rightarrow z,{ }^{\prime} j, t}^{\mathrm{F}} \geq \sum_{e=t-\Delta_{z \rightarrow z^{\prime}+1}}^{e=t} x_{z \rightarrow z,^{\prime} j, e}^{\mathrm{F}} \\
    u_{z \rightarrow z,^{\prime} j, t}^{\mathrm{E}} \geq \sum_{e=t-\Delta_{z \rightarrow z^{\prime}+1}}^{e=t} x_{z \rightarrow z, j, e}^{\mathrm{E}} \quad \forall z \rightarrow z^{\prime} \in \mathbb{B}, j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
    u_{z \rightarrow z,^{\prime}j, t}^{\mathrm{F}} \geq \sum_{e=t+1}^{e=t+\Delta_{z \rightarrow z^{\prime}}} y_{z \rightarrow z,^{\prime} j, e}^{\mathrm{F}} \\
    u_{z \rightarrow z, j, t}^{\mathrm{E}} \geq \sum_{e=t+1}^{e=t+\Delta_{z \rightarrow z^{\prime}}} y_{z \rightarrow z,^{\prime} j, e}^{\mathrm{E}} \\
    \forall z \rightarrow z^{\prime} \in \mathbb{B}, j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}   \]</p><p><strong>Constraints</strong></p><p>The charging capability of truck stations is limited by their compression or liquefaction capacity.</p><p class="math-container">\[\begin{aligned}
    q_{z, j, t}^{\mathrm{CHA}} \overline{\mathrm{E}}_{j}^{\mathrm{TRU}} \leq H_{z, j}^{\mathrm{TRU}} \quad \forall z \in \mathbb{Z}, j \in \mathbb{J}, t \in \mathbb{T}
\end{aligned}    \]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/truck/h2_truck_all.jl#L17-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.h2_truck_investment-Tuple{JuMP.Model, Dict, Dict}" href="#DOLPHYN.h2_truck_investment-Tuple{JuMP.Model, Dict, Dict}"><code>DOLPHYN.h2_truck_investment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">h2_truck_investment(EP::Model, inputs::Dict, setup::Dict)</code></pre><p>This function includes investment variables, expressions and related constraints for H2 trucks.</p><p><strong>Variables</strong></p><p><strong>Truck capacity built and retired</strong></p><p class="math-container">\[\begin{aligned}
    v_{CAP,j}^{TRU} \geqslant 0
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
    v_{RETCAP,j}^{TRU} \geqslant 0
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
   v_{CAP,j}^{TRU} \geqslant 0
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
    v_{NEWCAP,j}^{TRU} \geqslant 0
\end{aligned}\]</p><p><strong>Constraints</strong></p><p>Truck retirements cannot retire more charge capacity than existing charge capacity</p><p class="math-container">\[\begin{aligned}
    v_{RETCAPNUM,j}^{TRU} \le v_{ExistNum,j}^{TRU}
\end{aligned}\]</p><p>Truck compression energyCannot retire more energy capacity than existing energy capacity</p><p class="math-container">\[\begin{aligned}
    v_{RETCAPEnergy,j}^{TRU} \le v_{ExistEnergyCap,j}^{TRU} 
\end{aligned}\]</p><p><strong>Expressions</strong></p><p class="math-container">\[\begin{aligned}
    C_{\mathrm{TRU}}^{\mathrm{o}}=&amp; \sum_{z \rightarrow z^{\prime} \in \mathbb{B}} \sum_{j \in \mathbb{J}} \sum_{t \in \mathbb{T}} \Omega_{t} \mathrm{~L}_{z \rightarrow z^{\prime}} \\
    &amp; \times\left(\mathrm{o}_{j}^{\mathrm{TRU}, \mathrm{F}} y_{z \rightarrow z,{ }^{\prime} j, t}^{\mathrm{F}}+\mathrm{o}_{j}^{\mathrm{TRU}, \mathrm{E}} y_{z \rightarrow z,,^{\prime} j, t}^{\mathrm{E}}\right)
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/model/truck/h2_truck_investment.jl#L17-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.hoursbefore-Tuple{Int64, Int64, UnitRange{Int64}}" href="#DOLPHYN.hoursbefore-Tuple{Int64, Int64, UnitRange{Int64}}"><code>DOLPHYN.hoursbefore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hoursbefore(p::Int, t::Int, b::UnitRange)</code></pre><p>Determines the time index b hours before index t in a landscape starting from t=1 which is separated into distinct periods of length p.</p><p>For example, if p = 10, 1 hour before t=1 is t=10, 1 hour before t=10 is t=9 1 hour before t=11 is t=20</p><p>to allow for example b=1:3 to fetch a Vector{Int} of the three hours before time index t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/thermal/thermal_commit.jl#L364-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.hydro_inter_period_linkage-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.hydro_inter_period_linkage-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.hydro_inter_period_linkage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydro_inter_period_linkage(EP::Model, inputs::Dict)</code></pre><p>This function creates variables and constraints enabling modeling of long duration storage resources when modeling representative time periods. <strong>Storage inventory balance at beginning of each representative period</strong> The constraints in this section are used to approximate the behavior of long-duration energy storage technologies when approximating annual grid operations by modeling operations over representative periods. Previously, the state of charge balance for storage (as defined in <code>storage_all()</code>) assumed that state of charge at the beginning and end of each representative period has to be the same. In other words, the amount of energy built up or consumed by storage technology <span>$o$</span> in zone <span>$z$</span> over the representative period <span>$m$</span>, <span>$\Delta Q_{o,z,m} = 0$</span>. This assumption implicitly excludes the possibility of transferring energy from one representative period to the other which could be cost-optimal when the capital cost of energy storage capacity is relatively small. To model long-duration energy storage using representative periods, we replace the state of charge equation, such that the first term on the right hand side accounts for change in storage inventory associated with representative period <span>$m$</span> (<span>$\Delta Q_{o,z,m}$</span>), which could be positive (net accumulation) or negative (net reduction).</p><p class="math-container">\[\begin{aligned}
&amp; \Gamma_{o,z,(m-1)\times \tau^{period}+1 } =\left(1-\eta_{o,z}^{loss}\right)\times \left(\Gamma_{o,z,m\times \tau^{period}} -\Delta Q_{o,z,m}\right) -  \\
&amp; \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,(m-1)\times \tau^{period}+1} + \eta_{o,z}^{charge}\Pi_{o,z,(m-1)\times \tau^{period}+1} \quad \forall o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, m \in \mathcal{M}
\end{aligned}\]</p><p>By definition <span>$\mathcal{T}^{start}=\{\left(m-1\right) \times \tau^{period}+1 | m \in \mathcal{M}\}$</span>, which implies that this constraint is defined for all values of <span>$t \in T^{start}$</span>. <strong>Storage inventory change input periods</strong> We need additional variables and constraints to approximate energy exchange between representative periods, while accounting for their chronological occurence in the original input time series data and the possibility that two representative periods may not be adjacent to each other (see Figure below). To implement this, we introduce a new variable <span>$Q_{o,z, n}$</span> that models inventory of storage technology <span>$o \in O$</span> in zone <span>$z$</span> in each input period <span>$n \in \mathcal{N}$</span>. Additionally we define a function mapping, <span>$f: n \rightarrow m$</span>, that uniquely maps each input period <span>$n$</span> to its corresponding representative period <span>$m$</span>. This mapping is available as an output of the process used to identify representative periods (E.g. k-means clustering <a href="https://www.sciencedirect.com/science/article/pii/S0360544218315238?casa_token=I-6GVNMtAVIAAAAA:G8LFXFqXxRGrXHtrzmiIGm02BusIUmm83zKh8xf1BXY81-dTnA9p2YI1NnGuzlYBXsxK12by">Mallapragada et al., 2018</a>). <img src="../assets/LDES_approach.png" alt="Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations"/> <em>Figure. Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations</em> The following two equations define the storage inventory at the beginning of each input period <span>$n+1$</span> as the sum of storage inventory at begining of previous input period <span>$n$</span> plus change in storage inventory for that period. The latter is approximated by the change in storage inventory in the corresponding representative period, identified per the mapping <span>$f(n)$</span>.  The second constraint relates the storage level of the last input period, <span>$|N|$</span>, with the storage level at the beginning of the first input period. Finally, if the input period is also a representative period, then a third constraint enforces that initial storage level estimated by the intra-period storage balance constraint should equal the initial storage level estimated from the inter-period storage balance constraints. Note that <span>$|N|$</span> refers to the last modeled period.</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,n+1} = Q_{o,z,n} + \Delta Q_{o,z,f(n)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in \mathcal{N}\setminus\{|N|\}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,1} = Q_{o,z,|N|} + \Delta Q_{o,z,f(|N|)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n = |N|
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,n} =\Gamma_{o,z,f(n)\times \tau^{period}} - \Delta Q_{o,z,m}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in   \mathcal{N}^{rep},
\end{aligned}\]</p><p>Finally, the next constraint enforces that the initial storage level for each input period <span>$n$</span> must be less than the installed energy capacity limit. This constraint ensures that installed energy storage capacity is consistent with the state of charge during both the operational time periods <span>$t$</span> during each sample period <span>$m$</span> as well as at the start of each chronologically ordered input period <span>$n$</span> in the full annual time series.</p><p class="math-container">\[\begin{aligned}
    Q_{o,z,n} \leq \Delta^{total, energy}_{o,z}
\quad \forall n \in \mathcal{N}, o \in \mathcal{O}^{LDES}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/hydro/hydro_inter_period_linkage.jl#L17-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.hydro_res-Tuple{JuMP.Model, Dict, Int64}" href="#DOLPHYN.hydro_res-Tuple{JuMP.Model, Dict, Int64}"><code>DOLPHYN.hydro_res</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydro_res(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>This module defines the operational constraints for reservoir hydropower plants.</p><p>Hydroelectric generators with water storage reservoirs (<span>$y \in \mathcal{W}$</span>) are effectively modeled as energy storage devices that cannot charge from the grid and instead receive exogenous inflows to their storage reservoirs, reflecting stream flow inputs. For resources with unknown reservoir capacity (<span>$y \in \mathcal{W}^{nocap}$</span>), their operation is parametrized by their generation efficiency, <span>$\eta_{y,z}^{down}$</span>, and energy inflows to the reservoir at every time-step, represented as a fraction of the total power capacity,(<span>$\rho^{max}_{y,z,t}$</span>).  In case reservoir capacity is known (<span>$y \in \mathcal{W}^{cap}$</span>), an additional parameter, <span>$\mu^{stor}_{y,z}$</span>, referring to the ratio of energy capacity to discharge power capacity, is used to define the available reservoir storage capacity.</p><p><strong>Storage inventory balance</strong></p><p>Reservoir hydro systems are governed by the storage inventory balance constraint given below. This constraint enforces that energy level of the reservoir resource <span>$y$</span> and zone <span>$z$</span> in time step <span>$t$</span> (<span>$\Gamma_{y,z,t}$</span>) is defined as the sum of the reservoir level in the previous time step, less the amount of electricity generated, <span>$\Theta_{y,z,t}$</span> (accounting for the generation efficiency, <span>$\eta_{y,z}^{down}$</span>), minus any spillage <span>$\varrho_{y,z,t}$</span>, plus the hourly inflows into the reservoir (equal to the installed reservoir discharged capacity times the normalized hourly inflow parameter <span>$\rho^{max}_{y,z, t}$</span>).</p><p class="math-container">\[\begin{aligned}
&amp;\Gamma_{y,z,t} = \Gamma_{y,z,t-1} -\frac{1}{\eta_{y,z}^{down}}\Theta_{y,z,t} - \varrho_{y,z,t} + \rho^{max}_{y,z,t} \times \Delta^{total}_{y,z}  \hspace{.1 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}^{interior} \\
&amp;\Gamma_{y,z,t} = \Gamma_{y,z,t+\tau^{period}-1} -\frac{1}{\eta_{y,z}^{down}}\Theta_{y,z,t} - \varrho_{y,z,t} + \rho^{max}_{y,z,t} \times \Delta^{total}_{y,z}  \hspace{.1 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}^{start}
\end{aligned}\]</p><p>We implement time-wrapping to endogenize the definition of the intial state prior to the first period with the following assumption. If time step <span>$t$</span> is the first time step of the year then storage inventory at <span>$t$</span> is defined based on last time step of the year. Alternatively, if time step <span>$t$</span> is the first time step of a representative period, then storage inventory at <span>$t$</span> is defined based on the last time step of the representative period. Thus, when using representative periods, the storage balance constraint for hydro resources does not allow for energy exchange between representative periods.</p><p>Note: in future updates, an option to model hydro resources with large reservoirs that can transfer energy across sample periods will be implemented, similar to the functions for modeling long duration energy storage in <code>long_duration_storage.jl</code>.</p><p><strong>Ramping Limits</strong></p><p>The following constraints enforce hourly changes in power output (ramps down and ramps up) to be less than the maximum ramp rates (<span>$\kappa^{down}_{y,z}$</span> and <span>$\kappa^{up}_{y,z}$</span> ) in per unit terms times the total installed capacity of technology y (<span>$\Delta^{total}_{y,z}$</span>).</p><p class="math-container">\[\begin{aligned}
&amp;\Theta_{y,z,t} - \Theta_{y,z,t-1} \leq \kappa^{up}_{y,z} \times \Delta^{total}_{y,z}
\hspace{2 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp;\Theta_{y,z,t-1} - \Theta_{y,z,t} \leq \kappa^{down}_{y,z} \Delta^{total}_{y,z}
\hspace{2 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>Ramping constraints are enforced for all time steps except the first time step of the year or first time of each representative period when using representative periods to model grid operations.</p><p><strong>Power generation and stream flow bounds</strong></p><p>Electricity production plus total spilled power from hydro resources is constrained to always be above a minimum output parameter, <span>$\rho^{min}_{y,z}$</span>, to represent operational constraints related to minimum stream flows or other demands for water from hydro reservoirs. Electricity production is constrained by either the the net installed capacity or by the energy level in the reservoir in the prior time step, whichever is more binding. For the latter constraint, the constraint for the first time step of the year (or the first time step of each representative period) is implemented based on energy storage level in last time step of the year (or last time step of each representative period).</p><p class="math-container">\[\begin{aligned}
&amp;\Theta_{y,z,t} + \varrho_{y,z,t}  \geq \rho^{min}_{y,z} \times \Delta^{total}_{y,z}
\hspace{2 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\Theta_{y,t}  \leq \times \Delta^{total}_{y,z}
\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t\in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\Theta_{y,z,t} \leq  \Gamma_{y,t-1}
\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t\in \mathcal{T}
\end{aligned}\]</p><p><strong>Reservoir energy capacity constraint</strong></p><p>In case the reservoir capacity is known (<span>$y \in W^{cap}$</span>), then an additional constraint enforces the total stored energy in each time step to be less than or equal to the available reservoir capacity. Here, the reservoir capacity is defined multiplying the parameter, <span>$\mu^{stor}_{y,z}$</span> with the available power capacity.</p><p class="math-container">\[\begin{aligned}
\Gamma_{y,z, t} \leq \mu^{stor}_{y,z}\times \Delta^{total}_{y,z}
\hspace{4 cm}  \forall y \in \mathcal{W}^{cap}, z \in \mathcal{Z}, t\in \mathcal{T}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/hydro/hydro_res.jl#L17-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.hydro_res_reserves-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.hydro_res_reserves-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.hydro_res_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydro_res_reserves(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>This module defines the modified constraints and additional constraints needed when modeling operating reserves</p><p><strong>Modifications when operating reserves are modeled</strong></p><p>When modeling operating reserves, the constraints regarding maximum power flow limits are modified to account for procuring some of the available capacity for frequency regulation (<span>$f_{y,z,t}$</span>) and &quot;updward&quot; operating (or spinning) reserves (<span>$r_{y,z,t}$</span>).</p><p class="math-container">\[\begin{aligned}
 \Theta_{y,z,t} + f_{y,z,t} +r_{y,z,t}  \leq  \times \Delta^{total}_{y,z}
\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t\in \mathcal{T}
\end{aligned}\]</p><p>The amount of downward frequency regulation reserves cannot exceed the current power output.</p><p class="math-container">\[\begin{aligned}
 f_{y,z,t} \leq \Theta_{y,z,t}
\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The amount of frequency regulation and operating reserves procured in each time step is bounded by the user-specified fraction (<span>$\upsilon^{reg}_{y,z}$</span>,<span>$\upsilon^{rsv}_{y,z}$</span>) of nameplate capacity for each reserve type, reflecting the maximum ramp rate for the hydro resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.</p><p class="math-container">\[\begin{aligned}
f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \Delta^{total}_{y,z}
\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T} \\
r_{y,z, t} \leq \upsilon^{rsv}_{y,z}\times \Delta^{total}_{y,z}
\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/hydro/hydro_res.jl#L177-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.investment_charge-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.investment_charge-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.investment_charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">investment_charge(EP::Model, inputs::Dict)</code></pre><p>This function defines the expressions and constraints keeping track of total available storage charge capacity across all resources as well as constraints on capacity retirements. The function also adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function.</p><p>The total capacity of each resource is defined as the sum of the existing capacity plus the newly invested capacity minus any retired capacity.</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total,charge}_{y,z} =(\overline{\Delta^{charge}_{y,z}}+\Omega^{charge}_{y,z}-\Delta^{charge}_{y,z}) \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z}
\end{aligned}\]</p><p>One cannot retire more capacity than existing capacity.</p><p class="math-container">\[\begin{aligned}
&amp;\Delta^{charge}_{y,z} \leq \overline{\Delta^{charge}_{y,z}}
	\hspace{4 cm}  \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z}
\end{aligned}\]</p><p>For resources where <span>$\overline{\Omega_{y,z}^{charge}}$</span> and <span>$\underline{\Omega_{y,z}^{charge}}$</span> is defined, then we impose constraints on minimum and maximum power capacity.</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total,charge}_{y,z} \leq \overline{\Omega}^{charge}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z} \\
&amp; \Delta^{total,charge}_{y,z}  \geq \underline{\Omega}^{charge}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}^{asym}, z \in \mathcal{Z}
\end{aligned}\]</p><p>In addition, this function adds investment and fixed O&amp;M related costs related to charge capacity to the objective function:</p><p class="math-container">\[\begin{aligned}
&amp; 	\sum_{y \in \mathcal{O}^{asym} } \sum_{z \in \mathcal{Z}}
	\left( (\pi^{INVEST,charge}_{y,z} \times    \Omega^{charge}_{y,z})
	+ (\pi^{FOM,charge}_{y,z} \times  \Delta^{total,charge}_{y,z})\right)
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/investment_charge.jl#L17-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.investment_energy-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.investment_energy-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.investment_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">investment_energy(EP::Model, inputs::Dict)</code></pre><p>This function defines the expressions and constraints keeping track of total available storage charge capacity across all resources as well as constraints on capacity retirements. The function also adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function.</p><p>The total capacity of each resource is defined as the sum of the existing capacity plus the newly invested capacity minus any retired capacity.</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total,energy}_{y,z} =(\overline{\Delta^{energy}_{y,z}}+\Omega^{energy}_{y,z}-\Delta^{energy}_{y,z}) \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}\]</p><p>One cannot retire more capacity than existing capacity.</p><p class="math-container">\[\begin{aligned}
&amp;\Delta^{energy}_{y,z} \leq \overline{\Delta^{energy}_{y,z}}
		\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}\]</p><p>For resources where <span>$\overline{\Omega_{y,z}^{energy}}$</span> and <span>$\underline{\Omega_{y,z}^{energy}}$</span> is defined, then we impose constraints on minimum and maximum power capacity.</p><p class="math-container">\[\begin{aligned}
&amp; \Delta^{total,energy}_{y,z} \leq \overline{\Omega}^{energy}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z} \\
&amp; \Delta^{total,energy}_{y,z}  \geq \underline{\Omega}^{energy}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{O}, z \in \mathcal{Z}
\end{aligned}\]</p><p>In addition, this function adds investment and fixed O\&amp;M related costs related to charge capacity to the objective function:</p><p class="math-container">\[\begin{aligned}
&amp; 	\sum_{y \in \mathcal{O} } \sum_{z \in \mathcal{Z}}
	\left( (\pi^{INVEST,energy}_{y,z} \times    \Omega^{energy}_{y,z})
	+ (\pi^{FOM,energy}_{y,z} \times  \Delta^{total,energy}_{y,z})\right)
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/investment_energy.jl#L17-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_cap_reserve_margin-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_cap_reserve_margin-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_cap_reserve_margin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_cap_reserve_margin(setup::Dict, path::AbstractString, sep::AbstractString, inputs_crm::Dict)</code></pre><p>Function for reading input parameters related to planning reserve margin constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_cap_reserve_margin.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_co2_cap-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_co2_cap-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_co2_cap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_co2_cap(setup::Dict, path::AbstractString, sep::AbstractString, inputs_co2::Dict)</code></pre><p>Function for reading input parameters related to CO<span>$_2$</span> emissions cap constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_co2_cap.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_co2_cap_hsc-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_co2_cap_hsc-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_co2_cap_hsc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_co2_cap_hsc(setup::Dict, path::AbstractString, sep::AbstractString, inputs_co2_hsc::Dict)</code></pre><p>Function for reading input parameters related to CO<span>$_2$</span> emissions cap constraints in hydrogen supply chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_co2_cap_hsc.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_energy_share_requirement-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_energy_share_requirement-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_energy_share_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_energy_share_requirement(setup::Dict, path::AbstractString, sep::AbstractString, inputs_ESR::Dict)</code></pre><p>Function for reading input parameters related to mimimum energy share requirement constraints (e.g. renewable portfolio standard or clean electricity standard policies).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_energy_share_requirement.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_fuels_data-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_fuels_data-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_fuels_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_fuels_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_fuel::Dict)</code></pre><p>Function for reading input parameters related to fuel costs and CO<span>$_2$</span> emission intensity of fuels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_fuels_data.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_generators_data-Tuple{Dict, AbstractString, AbstractString, Dict, Dict, Dict}" href="#DOLPHYN.load_generators_data-Tuple{Dict, AbstractString, AbstractString, Dict, Dict, Dict}"><code>DOLPHYN.load_generators_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_generators_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_gen::Dict, fuel_costs::Dict, fuel_CO2::Dict)</code></pre><p>Function for reading input parameters related to electricity generators (plus storage and flexible demand resources).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_generators_data.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_generators_variability-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_generators_variability-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_generators_variability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_generators_variability(setup::Dict, path::AbstractString, sep::AbstractString, inputs_genvar::Dict)</code></pre><p>Function for reading input parameters related to hourly maximum capacity factors for all generators (plus storage and flexible demand resources).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_generators_variability.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_demand-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_demand-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_demand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_demand(setup::Dict, path::AbstractString, sep::AbstractString, inputs_load::Dict)</code></pre><p>Function for reading input hydrogen demand of each zone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_demand.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_g2p-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_g2p-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_g2p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_g2p(setup::Dict, path::AbstractString, sep::AbstractString, inputs_gen::Dict)</code></pre><p>Function for reading input parameters of hydrogen to power generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_g2p.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_g2p_variability-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_g2p_variability-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_g2p_variability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_g2p_variability(setup::Dict, path::AbstractString, sep::AbstractString, inputs_genvar::Dict)</code></pre><p>Function for reading input parameters related to hourly maximum capacity factors for all hydrogen to power plants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_g2p_variability.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_gen-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_gen-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_gen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_gen(setup::Dict, path::AbstractString, sep::AbstractString, inputs_gen::Dict)</code></pre><p>Function for reading input parameters of hydrogen generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_gen.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_generators_variability-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_generators_variability-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_generators_variability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_generators_variability(setup::Dict, path::AbstractString, sep::AbstractString, inputs_genvar::Dict)</code></pre><p>Function for reading input parameters related to hourly maximum capacity factors for all hydrogen generators (plus storage).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_generators_variability.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_inputs-Tuple{Dict, Dict, AbstractString}" href="#DOLPHYN.load_h2_inputs-Tuple{Dict, Dict, AbstractString}"><code>DOLPHYN.load_h2_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_inputs(inputs::Dict,setup::Dict,path::AbstractString)</code></pre><p>Loads various data inputs from multiple input .csv files in path directory and stores variables in a Dict (dictionary) object for use in model() function</p><p>inputs: setup - dict object containing setup parameters path - string path to working directory</p><p>returns: Dict (dictionary) object containing all data inputs of hydrogen sector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_H2_inputs.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_pipeline_data-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_pipeline_data-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_pipeline_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_pipeline_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_nw::Dict)</code></pre><p>Function for reading input parameters related to the hydrogen transmission network via pipelines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_pipeline_data.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_h2_truck-Tuple{AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_h2_truck-Tuple{AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_h2_truck</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_h2_truck(path::AbstractString, sep::AbstractString, inputs_truck::Dict)</code></pre><p>Function for reading input parameters of hydrogen truck.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/load_inputs/load_h2_truck.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_inputs-Tuple{Dict, AbstractString}" href="#DOLPHYN.load_inputs-Tuple{Dict, AbstractString}"><code>DOLPHYN.load_inputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_inputs(setup::Dict,path::AbstractString)</code></pre><p>Loads various data inputs from multiple input .csv files in path directory and stores variables in a Dict (dictionary) object for use in model() function</p><p>inputs: setup - dict object containing setup parameters path - string path to working directory</p><p>returns: Dict (dictionary) object containing all data inputs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_inputs.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_load_data-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_load_data-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_load_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_load_data(setup::Dict, path::AbstractString, sep::AbstractString, inputs_load::Dict)</code></pre><p>Function for reading input parameters related to electricity load (demand).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_load_data.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_minimum_capacity_requirement-Tuple{AbstractString, AbstractString, Dict, Dict}" href="#DOLPHYN.load_minimum_capacity_requirement-Tuple{AbstractString, AbstractString, Dict, Dict}"><code>DOLPHYN.load_minimum_capacity_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_minimum_capacity_requirement(path::AbstractString,sep::AbstractString, inputs::Dict, setup::Dict)</code></pre><p>Function for reading input parameters related to mimimum capacity requirement constraints (e.g. technology specific deployment mandates).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_minimum_capacity_requirement.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_period_map-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_period_map-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_period_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_period_map(setup::Dict,path::AbstractString,sep::AbstractString, inputs::Dict)</code></pre><p>Function for reading input parameters related to mapping of representative time periods to full chronological time series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_period_map.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.load_reserves-Tuple{Dict, AbstractString, AbstractString, Dict}" href="#DOLPHYN.load_reserves-Tuple{Dict, AbstractString, AbstractString, Dict}"><code>DOLPHYN.load_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_reserves(setup::Dict,path::AbstractString,sep::AbstractString, inputs_res::Dict)</code></pre><p>Function for reading input parameters related to frequency regulation and operating reserve requirements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/load_inputs/load_reserves.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.long_duration_storage-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.long_duration_storage-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.long_duration_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">long_duration_storage(EP::Model, inputs::Dict)</code></pre><p>This function creates variables and constraints enabling modeling of long duration storage resources when modeling representative time periods.</p><p><strong>Storage inventory balance at beginning of each representative period</strong></p><p>The constraints in this section are used to approximate the behavior of long-duration energy storage technologies when approximating annual grid operations by modeling operations over representative periods. Previously, the state of charge balance for storage (as defined in <code>storage_all()</code>) assumed that state of charge at the beginning and end of each representative period has to be the same. In other words, the amount of energy built up or consumed by storage technology <span>$o$</span> in zone <span>$z$</span> over the representative period <span>$m$</span>, <span>$\Delta Q_{o,z,m} = 0$</span>. This assumption implicitly excludes the possibility of transferring energy from one representative period to the other which could be cost-optimal when the capital cost of energy storage capacity is relatively small. To model long-duration energy storage using representative periods, we replace the state of charge equation, such that the first term on the right hand side accounts for change in storage inventory associated with representative period <span>$m$</span> (<span>$\Delta Q_{o,z,m}$</span>), which could be positive (net accumulation) or negative (net reduction).</p><p class="math-container">\[\begin{aligned}
&amp; \Gamma_{o,z,(m-1)\times \tau^{period}+1 } =\left(1-\eta_{o,z}^{loss}\right)\times \left(\Gamma_{o,z,m\times \tau^{period}} -\Delta Q_{o,z,m}\right) -  \\
&amp; \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,(m-1)\times \tau^{period}+1} + \eta_{o,z}^{charge}\Pi_{o,z,(m-1)\times \tau^{period}+1} \quad \forall o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, m \in \mathcal{M}
\end{aligned}\]</p><p>By definition <span>$\mathcal{T}^{start}=\{\left(m-1\right) \times \tau^{period}+1 | m \in \mathcal{M}\}$</span>, which implies that this constraint is defined for all values of <span>$t \in T^{start}$</span>.</p><p><strong>Storage inventory change input periods</strong></p><p>We need additional variables and constraints to approximate energy exchange between representative periods, while accounting for their chronological occurence in the original input time series data and the possibility that two representative periods may not be adjacent to each other (see Figure below). To implement this, we introduce a new variable <span>$Q_{o,z, n}$</span> that models inventory of storage technology <span>$o \in O$</span> in zone <span>$z$</span> in each input period <span>$n \in \mathcal{N}$</span>. Additionally we define a function mapping, <span>$f: n \rightarrow m$</span>, that uniquely maps each input period <span>$n$</span> to its corresponding representative period <span>$m$</span>. This mapping is available as an output of the process used to identify representative periods (E.g. k-means clustering <a href="https://www.sciencedirect.com/science/article/pii/S0360544218315238?casa_token=I-6GVNMtAVIAAAAA:G8LFXFqXxRGrXHtrzmiIGm02BusIUmm83zKh8xf1BXY81-dTnA9p2YI1NnGuzlYBXsxK12by">Mallapragada et al., 2018</a>).</p><p><img src="../assets/LDES_approach.png" alt="Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations"/> <em>Figure. Modeling inter-period energy exchange via long-duration storage when using representative period temporal resolution to approximate annual grid operations</em></p><p>The following two equations define the storage inventory at the beginning of each input period <span>$n+1$</span> as the sum of storage inventory at begining of previous input period <span>$n$</span> plus change in storage inventory for that period. The latter is approximated by the change in storage inventory in the corresponding representative period, identified per the mapping <span>$f(n)$</span>.  The second constraint relates the storage level of the last input period, <span>$|N|$</span>, with the storage level at the beginning of the first input period. Finally, if the input period is also a representative period, then a third constraint enforces that initial storage level estimated by the intra-period storage balance constraint should equal the initial storage level estimated from the inter-period storage balance constraints. Note that <span>$|N|$</span> refers to the last modeled period.</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,n+1} = Q_{o,z,n} + \Delta Q_{o,z,f(n)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in \mathcal{N}\setminus\{|N|\}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,1} = Q_{o,z,|N|} + \Delta Q_{o,z,f(|N|)}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n = |N|
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
&amp; Q_{o,z,n} =\Gamma_{o,z,f(n)\times \tau^{period}} - \Delta Q_{o,z,m}
\quad \forall  o \in \mathcal{O}^{LDES}, z \in \mathcal{Z}, n \in   \mathcal{N}^{rep},
\end{aligned}\]</p><p>Finally, the next constraint enforces that the initial storage level for each input period <span>$n$</span> must be less than the installed energy capacity limit. This constraint ensures that installed energy storage capacity is consistent with the state of charge during both the operational time periods <span>$t$</span> during each sample period <span>$m$</span> as well as at the start of each chronologically ordered input period <span>$n$</span> in the full annual time series.</p><p class="math-container">\[\begin{aligned}
    Q_{o,z,n} \leq \Delta^{total, energy}_{o,z}
\quad \forall n \in \mathcal{N}, o \in \mathcal{O}^{LDES}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/long_duration_storage.jl#L17-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.minimum_capacity_requirement-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.minimum_capacity_requirement-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.minimum_capacity_requirement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minimum_capacity_requirement(EP::Model, inputs::Dict)</code></pre><p>The minimum capacity requirement constraint allows for modeling minimum deployment of a certain technology or set of eligible technologies across the eligible model zones and can be used to mimic policies supporting specific technology build out (i.e. capacity deployment targets/mandates for storage, offshore wind, solar etc.). The default unit of the constraint is in MW. For each requirement <span>$p \in \mathcal{P}^{MinCapReq}$</span>, we model the policy with the following constraint.</p><p class="math-container">\[\begin{aligned}
\sum_{y \in \mathcal{G} } \sum_{z \in \mathcal{Z} } \left( \epsilon_{y,z,p}^{MinCapReq} \times \Delta^{\text{total}}_{y,z} \right) \geq REQ_{p}^{MinCapReq} \hspace{1 cm}  \forall p \in \mathcal{P}^{MinCapReq}
\end{aligned}\]</p><p>Note that <span>$\epsilon_{y,z,p}^{MinCapReq}$</span> is the eligiblity of a generator of technology <span>$y$</span> in zone <span>$z$</span> of requirement <span>$p$</span> and will be equal to <span>$1$</span> for eligible generators and will be zero for ineligible resources. The dual value of each minimum capacity constraint can be interpreted as the required payment (e.g. subsidy) per MW per year required to ensure adequate revenue for the qualifying resources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/policies/minimum_capacity_requirement.jl#L17-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.must_run-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.must_run-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.must_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">must_run(EP::Model, inputs::Dict)</code></pre><p>This function defines the constraints for operation of `must-run&#39; or non-dispatchable resources, such as rooftop solar systems that do not receive dispatch signals, run-of-river hydroelectric facilities without the ability to spill water, or cogeneration systems that must produce a fixed quantity of heat in each time step. This resource type can also be used to model baseloaded or self-committed thermal generators that do not respond to economic dispatch.</p><p>For must-run resources (<span>$y\in \mathcal{MR}$</span>) output in each time period <span>$t$</span> must exactly equal the available capacity factor times the installed capacity, not allowing for curtailment. These resources are also not eligible for contributing to frequency regulation or operating reserve requirements.</p><p class="math-container">\[\begin{aligned}
\Theta_{y,z,t} = \rho^{max}_{y,z,t}\times \Delta^{total}_{y,z}
\hspace{4 cm}  \forall y \in \mathcal{MR}, z \in \mathcal{Z},t \in \mathcal{T}
\end{aligned}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/must_run/must_run.jl#L17-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.parse_data-Tuple{Any, Any}" href="#DOLPHYN.parse_data-Tuple{Any, Any}"><code>DOLPHYN.parse_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_data(myinputs)</code></pre><p>Get load, solar, wind, and other curves from the input data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.rmse_score-Tuple{Any, Any}" href="#DOLPHYN.rmse_score-Tuple{Any, Any}"><code>DOLPHYN.rmse_score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmse_score(y_true, y_pred)</code></pre><p>Calculates Root Mean Square Error.</p><p class="math-container">\[RMSE = \sqrt{\frac{1}{n}\Sigma_{i=1}^{n}{\Big(\frac{d_i -f_i}{\sigma_i}\Big)^2}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L89-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.scale_weights" href="#DOLPHYN.scale_weights"><code>DOLPHYN.scale_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_weights(W, H)</code></pre><p>Linearly scale weights W such that they sum to the desired number of timesteps (hours) H.</p><p class="math-container">\[w_j \leftarrow H \cdot \frac{w_j}{\sum_i w_i} \: \: \: \forall w_j \in W\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/time_domain_reduction/time_domain_reduction.jl#L423-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.solve_model-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.solve_model-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.solve_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function solve_model()</code></pre><p>inputs: EP - a JuMP model representing the energy optimization problem setup - a Dict containing GenX setup flags</p><p>description: Solves and extracts solution variables for later processing</p><p>returns: results EP model object with a set of DataFrames containing key results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/solve_model.jl#L52-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.storage-Tuple{JuMP.Model, Dict, Int64, Int64}" href="#DOLPHYN.storage-Tuple{JuMP.Model, Dict, Int64, Int64}"><code>DOLPHYN.storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage(EP::Model, inputs::Dict, Reserves::Int, OperationWrapping::Int, LongDurationStorage::Int)</code></pre><p>A wide range of energy storage devices (all <span>$o \in \mathcal{O}$</span>) can be modeled in GenX, using one of two generic storage formulations: (1) storage technologies with symmetric charge and discharge capacity (all <span>$o \in \mathcal{O}^{sym}$</span>), such as Lithium-ion batteries and most other electrochemical storage devices that use the same components for both charge and discharge; and (2) storage technologies that employ distinct and potentially asymmetric charge and discharge capacities (all <span>$o \in \mathcal{O}^{asym}$</span>), such as most thermal storage technologies or hydrogen electrolysis/storage/fuel cell or combustion turbine systems.</p><p><strong>Storage with symmetric charge and discharge capacity</strong></p><p>For storage technologies with symmetric charge and discharge capacity (all <span>$o \in \mathcal{O}^{sym}$</span>), charge rate, <span>$\Pi_{o,z,t}$</span>, is constrained by the total installed power capacity, <span>$\Omega_{o,z}$</span>. Since storage resources generally represent a `cluster&#39; of multiple similar storage devices of the same type/cost in the same zone, GenX permits storage resources to simultaneously charge and discharge (as some units could be charging while others discharge), with the simultaenous sum of charge, <span>$\Pi_{o,z,t}$</span>, and discharge, <span>$\Theta_{o,z,t}$</span>, also limited by the total installed power capacity, <span>$\Delta^{total}_{o,z}$</span>. These two constraints are as follows:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Pi_{o,z,t} + \Theta_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>These constraints are created with the function <code>storage_symmetric()</code> in <code>storage_symmetric.jl</code>.</p><p>If reserves are modeled, the following two constraints replace those above:</p><p class="math-container">\[\begin{aligned}
&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T}\\
&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} + \Theta_{o,z,t} + f^{discharge}_{o,z,t} + r^{discharge}_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{sym}, z \in \mathcal{Z}, t \in \mathcal{T} \\
\end{aligned}\]</p><p>where <span>$f^{charge}_{o,z,t}$</span> is the contribution of storage resources to frequency regulation while charging, <span>$f^{discharge}_{o,z,t}$</span> is the contribution of storage resources to frequency regulation while discharging, and <span>$r^{discharge}_{o,z,t}$</span> is the contribution of storage resources to upward reserves while discharging. Note that as storage resources can contribute to regulation and reserves while either charging or discharging, the proxy variables <span>$f^{charge}_{o,z,t}, f^{discharge}_{o,z,t}$</span> and <span>$r^{charge}_{o,z,t}, r^{discharge}_{o,z,t}$</span> are created for storage resources where the total contribution to regulation and reserves, <span>$f_{o,z,t}, r_{o,z,t}$</span> is the sum of the proxy variables.</p><p>These constraints are created with the function <code>storage_symmetric_reserves()</code> in <code>storage_symmetric.jl</code>.</p><p><strong>Storage with asymmetric charge and discharge capacity</strong></p><p>For storage technologies with asymmetric charge and discharge capacities (all <span>$o \in \mathcal{O}^{asym}$</span>), charge rate, <span>$\Pi_{o,z,t}$</span>, is constrained by the total installed charge capacity, <span>$\Delta^{total, charge}_{o,z}$</span>, as follows:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} \leq \Delta^{total, charge}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{asym}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>These constraints are created with the function <code>storage_asymmetric()</code> in <code>storage_asymmetric.jl</code>.</p><p>If reserves are modeled, the above constraint is replaced by the following:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} \leq \Delta^{total, charge}_{o,z} &amp; \quad \forall o \in \mathcal{O}^{asym}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>where <span>$f^{+}_{y=o,z,t}$</span> is the contribution of storage resources to frequency regulation while charging.</p><p>These constraints are created with the function <code>storage_asymmetric_reserves()</code> in <code>storage_asymmetric.jl</code>.</p><p><strong>All storage resources</strong></p><p>The following constraints apply to all storage resources, <span>$o \in \mathcal{O}$</span>, regardless of whether the charge/discharge capacities are symmetric or asymmetric.</p><p>The following two constraints track the state of charge of the storage resources at the end of each time period, relating the volume of energy stored at the end of the time period, <span>$\Gamma_{o,z,t}$</span>, to the state of charge at the end of the prior time period, <span>$\Gamma_{o,z,t-1}$</span>, the charge and discharge decisions in the current time period, <span>$\Pi_{o,z,t}, \Theta_{o,z,t}$</span>, and the self discharge rate for the storage resource (if any), <span>$\eta_{o,z}^{loss}$</span>.  The first of these two constraints enforces storage inventory balance for interior time steps <span>$(t \in \mathcal{T}^{interior})$</span>, while the second enforces storage balance constraint for the initial time step <span>$(t \in \mathcal{T}^{start})$</span>.</p><p class="math-container">\[\begin{aligned}
	&amp;  \Gamma_{o,z,t} =\Gamma_{o,z,t-1} - \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,t} + \eta_{o,z}^{charge}\Pi_{o,z,t} - \eta_{o,z}^{loss}\Gamma_{o,z,t-1}  \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}^{interior}\\
	&amp;  \Gamma_{o,z,t} =\Gamma_{o,z,t+\tau^{period}-1} - \frac{1}{\eta_{o,z}^{discharge}}\Theta_{o,z,t} + \eta_{o,z}^{charge}\Pi_{o,z,t} - \eta_{o,z}^{loss}\Gamma_{o,z,t+\tau^{period}-1}  \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}^{start}
\end{aligned}\]</p><p>When modeling the entire year as a single chronological period with total number of time steps of <span>$\tau^{period}$</span>, storage inventory in the first time step is linked to storage inventory at the last time step of the period representing the year. Alternatively, when modeling the entire year with multiple representative periods, this constraint relates storage inventory in the first timestep of the representative period with the inventory at the last time step of the representative period, where each representative period is made of <span>$\tau^{period}$</span> time steps. In this implementation, energy exchange between representative periods is not permitted. When modeling representative time periods, GenX enables modeling of long duration energy storage which tracks state of charge between representative periods enable energy to be moved throughout the year. If <code>LongDurationStorage=1</code> and <code>OperationWrapping=1</code>, this function calls <code>long_duration_storage()</code> in <code>long_duration_storage.jl</code> to enable this feature.</p><p>The next constraint limits the volume of energy stored at any time, <span>$\Gamma_{o,z,t}$</span>, to be less than the installed energy storage capacity, <span>$\Delta^{total, energy}_{o,z}$</span>. Finally, the maximum discharge rate for storage resources, <span>$\Pi_{o,z,t}$</span>, is constrained to be less than the discharge power capacity, <span>$\Omega_{o,z,t}$</span> or the state of charge at the end of the last period, <span>$\Gamma_{o,z,t-1}$</span>, whichever is lessor.</p><p class="math-container">\[\begin{aligned}
	&amp;  \Gamma_{o,z,t} \leq \Delta^{total, energy}_{o,z} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} \leq \Gamma_{o,z,t-1} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The above constraints are established in <code>storage_all()</code> in <code>storage_all.jl</code>.</p><p>If reserves are modeled, two pairs of proxy variables <span>$f^{charge}_{o,z,t}, f^{discharge}_{o,z,t}$</span> and <span>$r^{charge}_{o,z,t}, r^{discharge}_{o,z,t}$</span> are created for storage resources, to denote the contribution of storage resources to regulation or reserves while charging or discharging, respectively. The total contribution to regulation and reserves, <span>$f_{o,z,t}, r_{o,z,t}$</span> is then the sum of the proxy variables:</p><p class="math-container">\[\begin{aligned}
	&amp;  f_{o,z,t} = f^{charge}_{o,z,t} + f^{dicharge}_{o,z,t} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  r_{o,z,t} = r^{charge}_{o,z,t} + r^{dicharge}_{o,z,t} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The total storage contribution to frequency regulation (<span>$f_{o,z,t}$</span>) and reserves (<span>$r_{o,z,t}$</span>) are each limited specified fraction of installed discharge power capacity (<span>$\upsilon^{reg}_{y,z}, \upsilon^{rsv}_{y,z}$</span>), reflecting the maximum ramp rate for the storage resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.</p><p class="math-container">\[\begin{aligned}
	f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \Delta^{total}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T} \\
	r_{y,z, t} \leq \upsilon^{rsv}_{y,z}\times \Delta^{total}_{y,z}
	\hspace{4 cm}  \forall y \in \mathcal{W}, z \in \mathcal{Z}, t \in \mathcal{T}
	\end{aligned}\]</p><p>When charging, reducing the charge rate is contributing to upwards reserve and frequency regulation as it drops net demand. As such, the sum of the charge rate plus contribution to regulation and reserves up must be greater than zero. Additionally, the discharge rate plus the contribution to regulation must be greater than zero.</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} - f^{charge}_{o,z,t} - r^{charge}_{o,z,t} \geq 0 &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} - f^{discharge}_{o,z,t} \geq 0 &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>Additionally, when reserves are modeled, the maximum charge rate and contribution to regulation while charging can be no greater than the available energy storage capacity, or the difference between the total energy storage capacity, <span>$\Delta^{total, energy}_{o,z}$</span>, and the state of charge at the end of the previous time period, <span>$\Gamma_{o,z,t-1}$</span>. Note that for storage to contribute to reserves down while charging, the storage device must be capable of increasing the charge rate (which increase net load).</p><p class="math-container">\[\begin{aligned}
	&amp;  \Pi_{o,z,t} + f^{charge}_{o,z,t} \leq \Delta^{energy, total}_{o,z} - \Gamma_{o,z,t-1} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>Finally, the constraints on maximum discharge rate are replaced by the following, to account for capacity contributed to regulation and reserves:</p><p class="math-container">\[\begin{aligned}
	&amp;  \Theta_{o,z,t} + f^{discharge}_{o,z,t} + r^{discharge}_{o,z,t} \leq \Delta^{total}_{o,z} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}\\
	&amp;  \Theta_{o,z,t} + f^{discharge}_{o,z,t} + r^{discharge}_{o,z,t} \leq \Gamma_{o,z,t-1} &amp; \quad \forall o \in \mathcal{O}, z \in \mathcal{Z}, t \in \mathcal{T}
\end{aligned}\]</p><p>The above reserve related constraints are established by <code>storage_all_reserves()</code> in <code>storage_all.jl</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/storage.jl#L17-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.storage_all-Tuple{JuMP.Model, Dict, Int64, Int64}" href="#DOLPHYN.storage_all-Tuple{JuMP.Model, Dict, Int64, Int64}"><code>DOLPHYN.storage_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage_all(EP::Model, inputs::Dict, Reserves::Int, OperationWrapping::Int)</code></pre><p>Sets up variables and constraints common to all storage resources. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/storage_all.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.storage_asymmetric-Tuple{JuMP.Model, Dict, Int64}" href="#DOLPHYN.storage_asymmetric-Tuple{JuMP.Model, Dict, Int64}"><code>DOLPHYN.storage_asymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage_asymmetric(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>Sets up variables and constraints specific to storage resources with asymmetric charge and discharge capacities. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/storage_asymmetric.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.storage_asymmetric_reserves-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.storage_asymmetric_reserves-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.storage_asymmetric_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage_asymmetric_reserves(EP::Model, inputs::Dict)</code></pre><p>Sets up variables and constraints specific to storage resources with asymmetric charge and discharge capacities when reserves are modeled. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/storage_asymmetric.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.storage_symmetric-Tuple{JuMP.Model, Dict, Int64}" href="#DOLPHYN.storage_symmetric-Tuple{JuMP.Model, Dict, Int64}"><code>DOLPHYN.storage_symmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage_symmetric(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>Sets up variables and constraints specific to storage resources with symmetric charge and discharge capacities. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/storage_symmetric.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.storage_symmetric_reserves-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.storage_symmetric_reserves-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.storage_symmetric_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage_symmetric_reserves(EP::Model, inputs::Dict)</code></pre><p>Sets up variables and constraints specific to storage resources with symmetric charge and discharge capacities when reserves are modeled. See <code>storage()</code> in <code>storage.jl</code> for description of constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/storage/storage_symmetric.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.thermal-Tuple{JuMP.Model, Dict, Int64, Int64}" href="#DOLPHYN.thermal-Tuple{JuMP.Model, Dict, Int64, Int64}"><code>DOLPHYN.thermal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermal(EP::Model, inputs::Dict, UCommit::Int, Reserves::Int)</code></pre><p>The thermal module creates decision variables, expressions, and constraints related to thermal power plants e.g. coal, oil or natural gas steam plants, natural gas combined cycle and combustion turbine plants, nuclear, hydrogen combustion etc.</p><p>This module uses the following &#39;helper&#39; functions in separate files: <code>thermal_commit()</code> for thermal resources subject to unit commitment decisions and constraints (if any) and <code>thermal_no_commit()</code> for thermal resources not subject to unit commitment (if any).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/thermal/thermal.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.thermal_commit-Tuple{JuMP.Model, Dict, Int64}" href="#DOLPHYN.thermal_commit-Tuple{JuMP.Model, Dict, Int64}"><code>DOLPHYN.thermal_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermal_commit(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>This function defines the operating constraints for thermal power plants subject to unit commitment constraints on power plant start-ups and shut-down decision (<span>$y \in UC$</span>).</p><p>We model capacity investment decisions and commitment and cycling (start-up, shut-down) of thermal generators using the integer clustering technique developed in <a href="https://pennstate.pure.elsevier.com/en/publications/impact-of-unit-commitment-constraints-on-generation-expansion-pla">Palmintier, 2011</a>, <a href="https://dspace.mit.edu/handle/1721.1/79147">Palmintier, 2013</a>, and <a href="https://ieeexplore.ieee.org/document/6684593">Palmintier, 2014</a>. In a typical binary unit commitment formulation, each unit is either on or off. With the clustered unit commitment formulation, one or more cluster(s) of similar generators are clustered by type and zone (typically using heat rate and fixed O\&amp;M cost to create clusters), and the integer commitment state variable for each cluster varies from zero to the number of units in the cluster, <span>$\frac{\Delta^{total}_{y,z}}{\Omega^{size}_{y,z}}$</span>. As discussed in \cite{Palmintier2014}, this approach replaces the large set of binary commitment decisions and associated constraints, which scale directly with the number of individual units, with a smaller set of integer commitment states and  constraints, one for each cluster <span>$y$</span>. The dimensionality of the problem thus scales with the number of units of a given type in each zone, rather than by the number of discrete units, significantly improving computational efficiency. However, this method entails the simplifying assumption that all clustered units have identical parameters (e.g., capacity size, ramp rates, heat rate) and that all committed units in a given time step <span>$t$</span> are operating at the same power output per unit.</p><p><strong>Power balance expression</strong></p><p>This function adds the sum of power generation from thermal units subject to unit commitment (<span>$\Theta_{y \in UC,t \in T,z \in Z}$</span>) to the power balance expression.</p><p><strong>Startup and shutdown events (thermal plant cycling)</strong></p><p><em>Capacitated limits on unit commitment decision variables</em></p><p>Thermal resources subject to unit commitment (<span>$y \in \mathcal{UC}$</span>) adhere to the following constraints on commitment states, startup events, and shutdown events, which limit each decision to be no greater than the maximum number of discrete units installed (as per the following three constraints):</p><p class="math-container">\[\begin{aligned}
\nu_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\chi_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
\zeta_{y,z,t} \leq \frac{\Delta^{\text{total}}_{y,z}}{\Omega^{size}_{y,z}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 1-3 in the code)</p><p>where decision <span>$\nu_{y,z,t}$</span> designates the commitment state of generator cluster <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>, decision <span>$\chi_{y,z,t}$</span> represents number of startup decisions, decision <span>$\zeta_{y,z,t}$</span> represents number of shutdown decisions, <span>$\Delta^{\text{total}}_{y,z}$</span> is the total installed capacity, and parameter <span>$\Omega^{size}_{y,z}$</span> is the unit size.</p><p><em>Commitment state constraint linking start-up and shut-down decisions</em></p><p>Additionally, the following constarint maintains the commitment state variable across time, <span>$\nu_{y,z,t}$</span>, as the sum of the commitment state in the prior, <span>$\nu_{y,z,t-1}$</span>, period plus the number of units started in the current period, <span>$\chi_{y,z,t}$</span>, less the number of units shut down in the current period, <span>$\zeta_{y,z,t}$</span>:</p><p class="math-container">\[\begin{aligned}
&amp;\nu_{y,z,t} =\nu_{y,z,t-1} + \chi_{y,z,t} - \zeta_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}^{interior} \\
&amp;\nu_{y,z,t} =\nu_{y,z,t +\tau^{period}-1} + \chi_{y,z,t} - \zeta_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}^{start}
\end{aligned}\]</p><p>(See Constraint 4 in the code)</p><p>Like other time-coupling constraints, this constraint wraps around to link the commitment state in the first time step of the year (or each representative period), <span>$t \in \mathcal{T}^{start}$</span>, to the last time step of the year (or each representative period), <span>$t+\tau^{period}-1$</span>.</p><p><strong>Ramping constraints</strong></p><p>Thermal resources subject to unit commitment (<span>$y \in UC$</span>) adhere to the following ramping constraints on hourly changes in power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t-1} - \Theta_{y,z,t} &amp;\leq  \kappa^{down}_{y,z} \cdot \Omega^{size}_{y,z} \cdot (\nu_{y,z,t} - \chi_{y,z,t}) &amp; \\[6pt]
	\qquad &amp; - \: \rho^{min}_{y,z} \cdot \Omega^{size}_{y,z} \cdot \chi_{y,z,t} &amp; \hspace{0.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}  \\[6pt]
	\qquad &amp; + \: \text{min}( \rho^{max}_{y,z,t}, \text{max}( \rho^{min}_{y,z}, \kappa^{down}_{y,z} ) ) \cdot \Omega^{size}_{y,z} \cdot \zeta_{y,z,t} &amp;
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} - \Theta_{y,z,t-1} &amp;\leq  \kappa^{up}_{y,z} \cdot \Omega^{size}_{y,z} \cdot (\nu_{y,z,t} - \chi_{y,z,t}) &amp; \\[6pt]
	\qquad &amp; + \: \text{min}( \rho^{max}_{y,z,t}, \text{max}( \rho^{min}_{y,z}, \kappa^{up}_{y,z} ) ) \cdot \Omega^{size}_{y,z} \cdot \chi_{y,z,t} &amp; \hspace{0.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T} \\[6pt]
	\qquad &amp; - \: \rho^{min}_{y,z} \cdot \Omega^{size}_{y,z} \cdot \zeta_{y,z,t} &amp;
\end{aligned}\]</p><p>(See Constraints 5-6 in the code)</p><p>where decision <span>$\Theta_{y,z,t}$</span> is the energy injected into the grid by technology <span>$y$</span> in zone <span>$z$</span> at time <span>$t$</span>, parameter <span>$\kappa_{y,z,t}^{up|down}$</span> is the maximum ramp-up or ramp-down rate as a percentage of installed capacity, parameter <span>$\rho_{y,z}^{min}$</span> is the minimum stable power output per unit of installed capacity, and parameter <span>$\rho_{y,z,t}^{max}$</span> is the maximum available generation per unit of installed capacity. These constraints account for the ramping limits for committed (online) units as well as faster changes in power enabled by units starting or shutting down in the current time step.</p><p><strong>Minimum and maximum power output</strong></p><p>If not modeling regulation and spinning reserves, thermal resources subject to unit commitment adhere to the following constraints that ensure power output does not exceed minimum and maximum feasible levels:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{min}_{y,z} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{max}_{y,z} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 7-8 the code)</p><p>If modeling reserves and regulation, these constraints are replaced by those established in this <code>thermal_commit_reserves()</code>.</p><p><strong>Minimum and maximum up and down time</strong></p><p>Thermal resources subject to unit commitment adhere to the following constraints on the minimum time steps after start-up before a unit can shutdown again (minimum up time) and the minimum time steps after shut-down before a unit can start-up again (minimum down time):</p><p class="math-container">\[\begin{aligned}
	\nu_{y,z,t} \geq \displaystyle \sum_{\hat{t} = t-\tau^{up}_{y,z}}^t \chi_{y,z,\hat{t}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\frac{\overline{\Delta_{y,z}} + \Omega_{y,z} - \Delta_{y,z}}{\Omega^{size}_{y,z}} -  \nu_{y,z,t} \geq \displaystyle \sum_{\hat{t} = t-\tau^{down}_{y,z}}^t \zeta_{y,z,\hat{t}}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 9-10 in the code)</p><p>where <span>$\tau_{y,z}^{up|down}$</span> is the minimum up or down time for units in generating cluster <span>$y$</span> in zone <span>$z$</span>.</p><p>Like with the ramping constraints, the minimum up and down constraint time also wrap around from the start of each time period to the end of each period. It is recommended that users of GenX must use longer subperiods than the longest min up/down time if modeling UC. Otherwise, the model will report error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/thermal/thermal_commit.jl#L17-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.thermal_commit_reserves-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.thermal_commit_reserves-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.thermal_commit_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermal_commit_reserves(EP::Model, inputs::Dict)</code></pre><p>This function is called by the <code>thermal_commit()</code> function when regulation and reserves constraints are active and defines reserve related constraints for thermal power plants subject to unit commitment constraints on power plant start-ups and shut-down decisions.</p><p><strong>Maximum contributions to frequency regulation and reserves</strong></p><p>When modeling frequency regulation and reserves contributions, thermal units subject to unit commitment adhere to the following constraints which limit the maximum contribution to regulation and reserves in each time step to a specified maximum fraction (<span>$,\upsilon^{rsv}_{y,z}$</span>) of the commitment capacity in that time step (<span>$(\Omega^{size}_{y,z} \cdot \nu_{y,z,t})$</span>):</p><p class="math-container">\[\begin{aligned}
	f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \rho^{max}_{y,z,t} (\Omega^{size}_{y,z} \times \nu_{y,z,t}) \hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	r_{y,z,t} \leq \upsilon^{rsv}_{y,z} \times \rho^{max}_{y,z,t} (\Omega^{size}_{y,z} \times \nu_{y,z,t}) \hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>where <span>$f_{y,z,t}$</span> is the frequency regulation contribution limited by the maximum regulation contribution <span>$\upsilon^{reg}_{y,z}$</span>, and <span>$r_{y,z,t}$</span> is the reserves contribution limited by the maximum reserves contribution <span>$\upsilon^{rsv}_{y,z}$</span>. Limits on reserve contributions reflect the maximum ramp rate for the thermal resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.</p><p><strong>Minimum and maximum power output</strong></p><p>When modeling frequency regulation and spinning reserves contributions, thermal resources subject to unit commitment adhere to the following constraints that ensure the sum of power output and reserve and/or regulation contributions do not exceed minimum and maximum feasible power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} - f_{y,z,t} \geq \rho^{min}_{y,z} \times Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} + f_{y,z,t} + r_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Omega^{size}_{y,z} \times \nu_{y,z,t}
	\hspace{1.5cm} \forall y \in \mathcal{UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>Note there are multiple versions of these constraints in the code in order to avoid creation of unecessary constraints and decision variables for thermal units unable to provide regulation and/or reserves contributions due to input parameters (e.g. <code>Reg_Max=0</code> and/or <code>RSV_Max=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/thermal/thermal_commit.jl#L247-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.thermal_no_commit-Tuple{JuMP.Model, Dict, Int64}" href="#DOLPHYN.thermal_no_commit-Tuple{JuMP.Model, Dict, Int64}"><code>DOLPHYN.thermal_no_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermal_no_commit(EP::Model, inputs::Dict, Reserves::Int)</code></pre><p>This function defines the operating constraints for thermal power plants NOT subject to unit commitment constraints on power plant start-ups and shut-down decisions (<span>$y \in H \setminus UC$</span>).</p><p><strong>Ramping limits</strong></p><p>Thermal resources not subject to unit commitment (<span>$y \in H \setminus UC$</span>) adhere instead to the following ramping limits on hourly changes in power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t-1} - \Theta_{y,z,t} \leq \kappa_{y,z}^{down} \Delta^{\text{total}}_{y,z} \hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} - \Theta_{y,z,t-1} \leq \kappa_{y,z}^{up} \Delta^{\text{total}}_{y,z} \hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 1-2 in the code)</p><p>This set of time-coupling constraints wrap around to ensure the power output in the first time step of each year (or each representative period), <span>$t \in \mathcal{T}^{start}$</span>, is within the eligible ramp of the power output in the final time step of the year (or each representative period), <span>$t+\tau^{period}-1$</span>.</p><p><strong>Minimum and maximum power output</strong></p><p>When not modeling regulation and reserves, thermal units not subject to unit commitment decisions are bound by the following limits on maximum and minimum power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \geq \rho^{min}_{y,z} \times \Delta^{total}_{y,z}
	\hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Delta^{total}_{y,z}
	\hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>(See Constraints 3-4 in the code)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/thermal/thermal_no_commit.jl#L17-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.thermal_no_commit_reserves-Tuple{JuMP.Model, Dict}" href="#DOLPHYN.thermal_no_commit_reserves-Tuple{JuMP.Model, Dict}"><code>DOLPHYN.thermal_no_commit_reserves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">thermal_no_commit_reservesEP::Model, inputs::Dict)</code></pre><p>This function is called by the <code>thermal_no_commit()</code> function when regulation and reserves constraints are active and defines reserve related constraints for thermal power plants not subject to unit commitment constraints on power plant start-ups and shut-down decisions.</p><p><strong>Maximum contributions to frequency regulation and reserves</strong></p><p>Thermal units not subject to unit commitment adhere instead to the following constraints on maximum reserve and regulation contributions:</p><p class="math-container">\[\begin{aligned}
	f_{y,z,t} \leq \upsilon^{reg}_{y,z} \times \rho^{max}_{y,z,t} \Delta^{\text{total}}_{y,z} \hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	r_{y,z,t} \leq \upsilon^{rsv}_{y,z} \times \rho^{max}_{y,z,t} \Delta^{\text{total}}_{y,z} \hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>where <span>$f_{y,z,t}$</span> is the frequency regulation contribution limited by the maximum regulation contribution <span>$\upsilon^{reg}_{y,z}$</span>, and <span>$r_{y,z,t}$</span> is the reserves contribution limited by the maximum reserves contribution <span>$\upsilon^{rsv}_{y,z}$</span>. Limits on reserve contributions reflect the maximum ramp rate for the thermal resource in whatever time interval defines the requisite response time for the regulation or reserve products (e.g., 5 mins or 15 mins or 30 mins). These response times differ by system operator and reserve product, and so the user should define these parameters in a self-consistent way for whatever system context they are modeling.</p><p><strong>Minimum and maximum power output</strong></p><p>When modeling regulation and spinning reserves, thermal units not subject to unit commitment are bound by the following limits on maximum and minimum power output:</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} - f_{y,z,t} \geq \rho^{min}_{y,z} \times \Delta^{\text{total}}_{y,z}
	\hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p class="math-container">\[\begin{aligned}
	\Theta_{y,z,t} + f_{y,z,t} + r_{y,z,t} \leq \rho^{max}_{y,z,t} \times \Delta^{\text{total}}_{y,z}
	\hspace{1cm} \forall y \in \mathcal{H \setminus UC}, \forall z \in \mathcal{Z}, \forall t \in \mathcal{T}
\end{aligned}\]</p><p>Note there are multiple versions of these constraints in the code in order to avoid creation of unecessary constraints and decision variables for thermal units unable to provide regulation and/or reserves contributions due to input parameters (e.g. <code>Reg_Max=0</code> and/or <code>RSV_Max=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/model/resources/thermal/thermal_no_commit.jl#L124-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_HSC_outputs-Tuple{JuMP.Model, AbstractString, Dict, Dict}" href="#DOLPHYN.write_HSC_outputs-Tuple{JuMP.Model, AbstractString, Dict, Dict}"><code>DOLPHYN.write_HSC_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_HSC_outputs(EP::Model, path::AbstractString, setup::Dict, inputs::Dict)</code></pre><p>Function for the entry-point of hydrogen supply chain for writing the different output files. From here, onward several other functions are called, each for writing specific output files, like costs, capacities, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_HSC_outputs.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_capacity(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model))</code></pre><p>Function for writing the diferent capacities for the different generation technologies (starting capacities or, existing capacities, retired capacities, and new-built capacities).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_capacity.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_capacity_value-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#DOLPHYN.write_capacity_value-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>DOLPHYN.write_capacity_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_capacity_value(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, dfPower::DataFrame, dfCharge::DataFrame, dfResMar::DataFrame, dfCap::DataFrame)</code></pre><p>Function to write the capacity value of generation and storage resources to csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/capacity_reserve_margin/write_capacity_value.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_charge-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_charge-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_charge(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the charging energy values of the different storage technologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_charge.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_charging_cost-Tuple{AbstractString, AbstractString, Dict, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, Dict}" href="#DOLPHYN.write_charging_cost-Tuple{AbstractString, AbstractString, Dict, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, Dict}"><code>DOLPHYN.write_charging_cost</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_charging_cost(path::AbstractString, sep::AbstractString, inputs::Dict, dfCharge::DataFrame, dfPrice::DataFrame, dfPower::DataFrame, setup::Dict)</code></pre><p>Function for reporting charging costs of each resource.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_charging_cost.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_commit-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_commit-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_commit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_commit(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting committment states for each resource at each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/ucommit/write_commit.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_costs-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_costs-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_costs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_costs(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the costs pertaining to the objective function (fixed, variable O&amp;M etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_costs.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_curtailment-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_curtailment-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_curtailment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_curtailment(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the curtailment values of the different variable renewable resources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_curtailment.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_emissions-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_emissions-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_emissions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_emissions(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting time-dependent CO<span>$_2$</span> emissions by zone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_emissions.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_energy_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#DOLPHYN.write_energy_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>DOLPHYN.write_energy_revenue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_energy_revenue(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model, dfPower::DataFrame, dfPrice::DataFrame, dfCharge::DataFrame)</code></pre><p>Function for writing energy revenue from the different generation technologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_energy_revenue.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_esr_prices-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_esr_prices-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_esr_prices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_esr_prices(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function to write prices under energy share requirements.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/energy_share_requirement/write_esr_prices.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_esr_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, DataFrames.DataFrame}" href="#DOLPHYN.write_esr_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, DataFrames.DataFrame}"><code>DOLPHYN.write_esr_revenue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_esr_revenue(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, dfPower::DataFrame, dfESR::DataFrame)</code></pre><p>Function for reporting the renewable/clean credit revenue earned by each generator listed in the input file. GenX will print this file only when RPS/CES is modeled and the shadow price can be obtained form the solver. Each row corresponds to a generator, and each column starting from the 6th to the second last is the total revenue earned from each RPS constraint. The revenue is calculated as the total annual generation (if elgible for the corresponding constraint) multiplied by the RPS/CES price. The last column is the total revenue received from all constraint. The unit is <span>$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/energy_share_requirement/write_esr_revenue.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_g2p_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_g2p_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_g2p_capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_g2p_capacity(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the diferent capacities for the different hydrogen to power technologies (starting capacities or, existing capacities, retired capacities, and new-built capacities).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_g2p_capacity.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_balance-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_balance-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_balance(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing hydrogen balance data to csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_balance.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_capacity(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the capacities for the different hydrogen resources (starting capacities or, existing capacities, retired capacities, and new-built capacities).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_capacity.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_charge-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_charge-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_charge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_charge(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the h2 storage charging values of the different hydrogen storage technologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_charge.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_costs-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_costs-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_costs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_costs(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the costs of hydrogen supply chain pertaining to the objective function (fixed, variable O&amp;M etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_costs.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_emissions-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_emissions-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_emissions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_emissions(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting time-dependent CO<span>$_2$</span> emissions by zone in hydrogen supply chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_emissions.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_g2p-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_g2p-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_g2p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_g2p(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the different values of power generated by hydrogen to power plants in operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_g2p.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_gen-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_gen-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_gen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_gen(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the different values of hydrogen generated by the different technologies in operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_gen.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_nse-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_nse-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_nse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_nse(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting non-served hydrogen for every model zone, time step and cost-segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_nse.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_pipeline_expansion-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_pipeline_expansion-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_pipeline_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_pipeline_expansion(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the expansion of hydrogen pipelines.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_pipeline_expansion.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_pipeline_flow-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_pipeline_flow-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_pipeline_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_pipeline_flow(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the hydrogen flow via pipeliens.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_pipeline_flow.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_storage-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_storage-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_storage(path::AbstractString, sep::AbstractString, inputs::Dict,setup::Dict, EP::Model)</code></pre><p>Function for writing the capacities of different hydrogen storage technologies, including hydro reservoir, flexible storage tech etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_storage.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_truck_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_truck_capacity-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_truck_capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_truck_capacity(path::AbstractString, sep::AbstractString, inputs::Dict,setup::Dict, EP::Model)</code></pre><p>Functions for writing capacities of hydrogen trucks (starting capacities or, existing capacities, retired capacities, and new-built capacities).    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_truck_capacity.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_h2_truck_flow-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_h2_truck_flow-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_h2_truck_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_h2_truck_flow(path::AbstractString, sep::AbstractString, inputs::Dict,setup::Dict, EP::Model)</code></pre><p>Fucntion for writing hydrogen flow via trucsk.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_h2_truck_flow.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_net_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#DOLPHYN.write_net_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>DOLPHYN.write_net_revenue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_net_revenue(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model, dfCap::DataFrame, dfESRRev::DataFrame, dfResRevenue::DataFrame, dfChargingcost::DataFrame, dfPower::DataFrame, dfEnergyRevenue::DataFrame, dfSubRevenue::DataFrame, dfRegSubRevenue::DataFrame)</code></pre><p>Function for writing network revenue of different generation technologies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_net_revenue.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_nse-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_nse-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_nse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_nse(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting non-served energy for every model zone, time step and cost-segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_nse.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_nw_expansion-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_nw_expansion-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_nw_expansion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_nw_expansion(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting the expansion statuses of electricity network expansion.	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/transmission/write_nw_expansion.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_opwrap_lds_dstor-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_opwrap_lds_dstor-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_opwrap_lds_dstor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_opwrap_lds_dstor(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing long duration storage related operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/long_duration_storage/write_opwrap_lds_dstor.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_outputs-Tuple{JuMP.Model, AbstractString, Dict, Dict}" href="#DOLPHYN.write_outputs-Tuple{JuMP.Model, AbstractString, Dict, Dict}"><code>DOLPHYN.write_outputs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_outputs(EP::Model, path::AbstractString, setup::Dict, inputs::Dict)</code></pre><p>Function for the entry-point for writing the different output files. From here, onward several other functions are called, each for writing specific output files, like costs, capacities, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_outputs.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_p_g2p-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_p_g2p-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_p_g2p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_p_g2p(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the different values of power generated by hydrogen to power plants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/HSC/write_outputs/write_p_g2p.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_power-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_power-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_power</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_power(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for writing the different values of power generated by the different technologies in operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_power.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_power_balance-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_power_balance-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_power_balance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_power_balance(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting power balance of resources across different zones.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_power_balance.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_price-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_price-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_price</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_price(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting marginal electricity price for each model zone and time step. Marginal electricity price is equal to the dual variable of the load balance constraint. If GenX is configured as a mixed integer linear program, then this output is only generated if <code>WriteShadowPrices</code> flag is activated. If configured as a linear program (i.e. linearized unit commitment or economic dispatch) then output automatically available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_price.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_reg-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_reg-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_reg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_reg(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function to write the regulation action to csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/reserves/write_reg.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_reliability-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_reliability-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_reliability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_reliability(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting dual variable of maximum non-served energy constraint (shadow price of reliability constraint) for each model zone and time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_reliability.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_reserve_margin_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}" href="#DOLPHYN.write_reserve_margin_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame, DataFrames.DataFrame}"><code>DOLPHYN.write_reserve_margin_revenue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_reserve_margin_revenue(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, dfPower::DataFrame, dfCharge::DataFrame, dfResMar::DataFrame, dfCap::DataFrame)</code></pre><p>Function for reporting the capacity revenue earned by each generator listed in the input file. GenX will print this file only when capacity reserve margin is modeled and the shadow price can be obtained form the solver. Each row corresponds to a generator, and each column starting from the 6th to the second last is the total revenue from each capacity reserve margin constraint. The revenue is calculated as the capacity contribution of each time steps multiplied by the shadow price, and then the sum is taken over all modeled time steps. The last column is the total revenue received from all capacity reserve margin constraints.  As a reminder, GenX models the capacity reserve margin (aka capacity market) at the time-dependent level, and each constraint either stands for an overall market or a locality constraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/capacity_reserve_margin/write_reserve_margin_revenue.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_rsv-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_rsv-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_rsv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_rsv(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function to write the reserve action operations to csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/reserves/write_rsv.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_shutdown-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_shutdown-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_shutdown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_shutdown(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting the shutdown action of resources at each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/ucommit/write_shutdown.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_start-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_start-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_start</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_start(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Fucntion for reporting startup action of resources at each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/ucommit/write_start.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_status-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_status-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_status(path::AbstractString, sep::AbstractString, inputs::Dict, EP::Model)</code></pre><p>Function for writing the final solve status of the optimization problem solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_status.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_storage-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_storage-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_storage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_storage(path::AbstractString, sep::AbstractString, inputs::Dict,setup::Dict, EP::Model)</code></pre><p>Function for writing the capacities of different storage technologies, including hydro reservoir, flexible storage tech etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_storage.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_storagedual-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_storagedual-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_storagedual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_storagedual(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting dual of storage level (state of charge) balance of each resource in each time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_storagedual.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_subsidy_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, JuMP.Model}" href="#DOLPHYN.write_subsidy_revenue-Tuple{AbstractString, AbstractString, Dict, Dict, DataFrames.DataFrame, JuMP.Model}"><code>DOLPHYN.write_subsidy_revenue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_subsidy_revenue(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, dfCap::DataFrame, EP::Model)</code></pre><p>Function for reporting subsidy revenue earned if a generator specified <code>Min_Cap</code> is provided in the input file. GenX will print this file only the shadow price can be obtained form the solver. Do not confuse this with the Minimum Capacity Carveout constraint, which is for a subset of generators, and a separate revenue term will be calculated in other files. The unit is <span>$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_subsidy_revenue.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_time_weights-Tuple{AbstractString, AbstractString, Dict}" href="#DOLPHYN.write_time_weights-Tuple{AbstractString, AbstractString, Dict}"><code>DOLPHYN.write_time_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_time_weights(path::AbstractString, sep::AbstractString, inputs::Dict)</code></pre><p>Function for reporting the time weights after clustering process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/write_time_weights.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_transmission_flows-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_transmission_flows-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_transmission_flows</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_transmission_flows(path::AbstractString, sep::AbstractString, setup::Dict, inputs::Dict, EP::Model)</code></pre><p>Function for reporting electricity flow via transmision lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/transmission/write_transmission_flows.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DOLPHYN.write_transmission_losses-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}" href="#DOLPHYN.write_transmission_losses-Tuple{AbstractString, AbstractString, Dict, Dict, JuMP.Model}"><code>DOLPHYN.write_transmission_losses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_transmission_losses(path::AbstractString, sep::AbstractString, inputs::Dict, setup::Dict, EP::Model)</code></pre><p>Function for reporting electricity losses during transmission via lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gn-he/DOLPHYN-dev/blob/a1e2f820d2fe3033882f7477731bc4df75b57ad4/src/GenX/write_outputs/transmission/write_transmission_losses.jl#L17-L21">source</a></section></article><h2 id="Hydrogen-Output"><a class="docs-heading-anchor" href="#Hydrogen-Output">Hydrogen Output</a><a id="Hydrogen-Output-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen-Output" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../write_h2_outputs/">« HSC Outputs Functions</a><a class="docs-footer-nextpage" href="../h2_flexible_demand/">Hydrogen Flexible Demand »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 22 June 2022 01:42">Wednesday 22 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
